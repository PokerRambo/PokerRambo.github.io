<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python之word文档批量处理]]></title>
    <url>%2F2021%2F05%2F27%2FPython%E4%B9%8Bword%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[在文字工作中，经常会碰到与需要批量生成、编辑word文档的需求，这类机械性的工作非常适合编写小工具进行批量处理，使得原本人工处理需要几小时的工作量缩短为几分钟。 工具介绍Python下处理word文档最好用的库为 python-docx, 目前已收入pypi，直接使用pip安装即可。 新建文档可以新建一个空白文档 Document ，如下： 123from docx import Documentdocument = Document() 编辑现有文档将现存文件的路径传给Document类即可。 1234from docx import Documentdocument = Document('myfile.docx')document.save('new-file-name.docx') 新建标题新建一个标题, 其中level参数可选，有1-9中规格，代表标题级别。 1document.add_heading('新建标题', level=1) 新建段落创建段落 paragraph 的操作如下： 1paragraph = document.add_paragraph('新建段落。') 设置段落样式12paragraph = document.add_paragraph('这是一个样式为 ListBullet 的段落')paragraph.style = 'List Bullet' 设置段落对齐方式段落对齐方式有 左对齐 、 文字居中 、 右对齐 、 两端对齐，更多对齐方式请参考 WD_ALIGN_PARAGRAPH 12345678910from docx.enum.text import WD_ALIGN_PARAGRAPH# LEFT =&gt; 左对齐# CENTER =&gt; 文字居中# RIGHT =&gt; 右对齐# JUSTIFY =&gt; 文本两端对齐paragraph = document.add_paragraph("对其方式测试")paragraph_format = paragraph.paragraph_formatparagraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER 设置段落缩进设置段落缩进，可为负值： 1234from docx.shared import Inchesparagraph = document.add_paragraph("这是缩进")paragraph.paragraph_format.left_indent = Inches(0.5) 也可以设置首行缩进: 1paragraph.paragraph_format.first_line_indent = Inches(0.5) 设置段落行距当行距为 最小值 和 固定值 时，设置值单位为 磅 ，需要用 Pt ；当行距为 多倍行距 时，设置值为数值，如下： 12345678910111213from docx.enum.text import WD_LINE_SPACING#SINGLE =&gt; 单倍行距（默认）#ONE_POINT_FIVE =&gt; 1.5倍行距#DOUBLE2 =&gt; 倍行距#AT_LEAST =&gt; 最小值#EXACTLY =&gt; 固定值#MULTIPLE =&gt; 多倍行距paragraph.line_spacing_rule = WD_LINE_SPACING.EXACTLY #固定值paragraph.paragraph_format.line_spacing = Pt(18) # 固定值18磅paragraph.line_spacing_rule = WD_LINE_SPACING.MULTIPLE #多倍行距paragraph.paragraph_format.line_spacing = 1.75 # 1.75倍行间距 片段设置（Run）段落包含很多块级的格式，比如缩进、行高、制表符等。每一个小片段叫做一个 run ，可以对 run 设置粗体和斜体等属性。 123456paragraph = document.add_paragraph()paragraph.add_run('这是一个带有')paragraph.add_run('粗体').bold = Trueparagraph.add_run('和')paragraph.add_run('斜体').italic = Trueparagraph.add_run('的段落。') 更多参考资料中文：https://zhuanlan.zhihu.com/p/61340025 官方文档 ：https://python-docx.readthedocs.io/en/latest/index.html 案例介绍假设我们需要生成如下的代开发票委托书，客户名字和身份证号来源于其他文件（可以是txt，excel），如果手动进行复制粘贴，费时费力，不如用上一节介绍的工具进行批量处理。 下面示例代码用于生成上图中的模板文档，中文可以自行替换; 函数接收姓名、身份证号组成的列表作为 参数（另有代码进行处理，从其他 文件获得），如[(&#39;小明&#39;, 330201xxxxxxxxxxxxx1410), ..., (&#39;小红&#39;, 330205xxxxxxxxxxxxx1701)] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def generate_doc(namelist): # 授权正文 content = '兹委托 xxx （身份证件号：xxxxxxxxxxxxxxxxxxxxxxxxx ）' \ '到国税机关办理代开增值税普通发票税务事项。委托人和代理人严格遵守有关税收法律法规。' # 以下为生成保密协议的代码，name_list中的每个人员都将生成对应一份保密协议文档 for names in name_list: # 创建内存中的word文档对象 file = docx.Document() file.styles['Normal'].font.name = u'宋体' file.styles['Normal']._element.rPr.rFonts.set(qn('w:eastAsia'), u'宋体') # 可换成word里面任意字体 # 写入若干段落 p1 = file.add_paragraph() p1.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER # 段落文字居中设置 run = p1.add_run("办理税务事项授权委托书") run.font.size = docx.shared.Pt(20) run.bold = True # 抬头 head = file.add_paragraph() head.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.LEFT run = head.add_run("\n\n上海市长宁区国家税务局：\n") run.font.size = docx.shared.Pt(14) # 四号字体 run.bold = True # 个人信息 p2 = file.add_paragraph() # p2.line_spacing_rule = WD_LINE_SPACING.ONE_POINT_FIVE p2.paragraph_format.line_spacing_rule = WD_LINE_SPACING.DOUBLE p2.paragraph_format.first_line_indent = Inches(0.5) p2.add_run('本人，').font.size = docx.shared.Pt(14) run = p2.add_run('%s' % names[0]) run.font.size = docx.shared.Pt(14) p2.add_run('（身份证件号：').font.size = docx.shared.Pt(14) run = p2.add_run('%s）' % names[1]) run.font.size = docx.shared.Pt(14) p2.add_run(content + '\n').font.size = docx.shared.Pt(14) p3 = file.add_paragraph() run = p3.add_run('委托人签名： 代理人签名：\n') run.font.size = docx.shared.Pt(14) run.bold = True p5 = file.add_paragraph() p5.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.RIGHT run = p5.add_run("2021 年 5 月") run.font.size = docx.shared.Pt(14) run.bold = True # 保存 file.save("办理税务事项授权委托书-%s.docx" % names[0]) 如需完整代码，可以关注公众号”CodingSirTutor”, 回复“word批量处理”获取；如需定制文件模板或有特殊需求，可添加wx助手：caxiaozhushou咨询。]]></content>
      <categories>
        <category>办公技巧</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>办公技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之数据分析学习路径]]></title>
    <url>%2F2021%2F04%2F25%2FPython%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[应浙江大学心理系研博会邀请，笔者于24日晚做了一场关于利用Python进行数据分析的讲座，现将分享的材料稍作整理，希望能帮助更多的在科研等活动中需要此类工具的同学。 工具链与流程从全景视角来看数据分析，我们需要关心的只有两个部分：1. 有哪些工具可以使用？2. 整体的流程是怎么样的？ 一般地，数据分析需要的工具可以分为几类： 解释器：python3.5 + , python2已经停止维护了，所以不推荐, 官网链接。 环境管理工具： Anaconda 已经包含大部分数据科学相关的三方库，无需再手动安装，官网链接。 编辑器： Jupyter Notebook, 可以将公式、分析、代码、结果等结合在一个文档中，非常方便梳理思路和展示成果，支持部署在本地或远程服务器中，通过浏览器访问，更加轻便， 官网链接。 第三方库： NumPy：提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库，官方文档。 Pandas: 基于NumPy的一种工具，为了解决数据分析任务而创建，可以处理不规整的数据。Pandas 纳入了一些标准的数据模型，提供了高效操作百万级别数据集所需的工具。官方文档。 SciPy: 一个用于数学、科学、工程领域的常用软件包，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。官方文档 Scikit-Learn: 集成了众多的机器学习模型，主要分为六个部分，分类、回归、聚类、数据降维、模型选择、数据预处理。官方文档。 statsmodels: 用于拟合多种统计模型，执行统计测试。statsmodels包含更多的“经典”频率学派统计方法，而贝叶斯方法和机器学习模型可在其他库中找到。官方文档。 Matplotlib(Seaborn): 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形, 可以通过几行代码生成各种统计图表。Seaborn在Matplotlib基础上构建，能够提供更好的视觉效果。Matplotlib官方文档，Seaborn官方文档。 数据分析的流程可以概括为四个大步骤： 数据采集 内部数据 开源数据 爬虫爬取 购买数据 数据预处理： 看似最不起眼的步骤，往往消耗最多的时间。 数据导入 数据检查 数据清洗 数据规约 数据变换 数据聚合 数据分析（部分方法）：重点在于理解理论背后的思想，至于编程工作往往只需调用一下API即可。 假设检验 方差分析 相关分析 回归分析 据类分析 因子分析 时间序列分析 数据或结果可视化 图表：柱状图、折线图、散点图等等。（详细类型及适用范围见下图，图片来源知乎） 工具：Python、Excel或其他BI工具均可。 学习资料分享授人以鱼不如授人以渔，这一节分享关于Python基础和数据分析的相关资料，包含视频、博客、书籍等。一般地，对初学者来说，以视频课程学习为先，第一是因为视频可以较为完整的呈现编程的过程，而文字资料不太容易面面俱到，且视频课程往往有讨论区和课后作业，能够给学生提供良性的反馈，事半功倍；当初步入门的时候，视频学习的效率是不如书籍或博客的，文字资料可以快速定位至感兴趣的章节进行重点学习，而视频较为困难；当开始着手项目时，就更适合挑选大而全的资料作为一个字典，有问题时再查询。不同阶段适合使用不同的资料，无需持一种非此即彼的态度。 Python资料对于没有Python基础的同学来说，那就必须先搞定语言基础，下面列举一些质量有保证的资料： 视频课程，有作业和讨论区，能够及时得到反馈，最适合小白的方式。 Coursera: Python for Everybody specialization (University of Michigan, Charles Severance) 注：coursera有些课程需要注册费，但也可以写申请信免费上课，如果确实经济上力有不逮，可以走这个通道。 Coursera: Introduction to Scripting in Python Specialization (Rice University) Datacamp: Data Analyst Track 中国大学MOOC Python程序语言设计 Python 官方文档 系列博客： 廖雪峰Python教程 菜鸟教程 问题解决（不止适用于python, 编程世界的大部分疑难解决方案都在其中）： stackoverflow: 一般的编程问题（bug）都可以找到答案，重点是合理的描述问题。 Geeksforgeeks: 更综合一点的博客，更多的是给出一个具体的问题的解决方案。 Github repo的issue区：遇到少见的报错，如果前面几种方式都无法解决，可以看看官方库中的issue是否对此有说明，有可能并不是你的问题。 math stackexchange: 数学问题解答社区，比较适合数据科学。 搜索引擎： google为上，baidu为下。常备一些常用的搜索引擎技巧，如指定特定网站搜索、指定文件类型搜索等。 数据分析学习资料其中公开课和书籍是帮助建立起数据分析的完整图景，代码示例可以尝试这修改来验证自己的想法，各类库的文档和cheating sheet主要用来检索合适的API。 公开课 Python数据分析与展示 借助 Python 应用数据科学专项课程（看前两个） 书籍： https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version 代码（和上书对应）： https://github.com/wesm/pydata-book 各类库的官方文档（部分）： Pandas: https://www.pypandas/ Numpy: https://www.numpy.org/ Matplotlib: https://matplotlib.org/ Cheating sheets, 下图为Pandas的部分API及使用范例，更多sheet详见以下repo。 https://github.com/PokerRambo/Data-Science--Cheat-Sheet 更多编程学习内容可以关注公众号”CodingSirTutor”, 回复“心理系讲座”获取讲座ppt及案例代码文件。]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人应对矿潮的方法]]></title>
    <url>%2F2021%2F04%2F18%2F%E4%B8%AA%E4%BA%BA%E5%BA%94%E5%AF%B9%E7%9F%BF%E6%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[4839fa8b1271302c8f89ffee54309074973200e214df809c00c7a64351ba72b54224193a57bf4189f65d08d71491229743f674969a7669d8af451f7eb6fe29e99997918fa7e0314f6068739b2d0adf54656ab23d6d6714688485636907a07b5d35acdc3d90ef036f0e4c3338012f92b1cada46e1648f83f261f76d4e1c70d1b4b48cc9752f122a20f407192778d77f71b53fa540e6f39a9bd4b2a96bbc27299fe666bf57fe6b4e7d8fa9327a99110b57aa7e479720bf3bf2792950d194941a8672f7501be8dd3626b2f4e7c733b791e7d44327482a2bee385189b20613794ca57d6220b4075c9b8078173280aba6e497ee78879ff9fe3b2696aa8ae0dd1dcd195de5180960b34c8d9cb358b5ddb6172c5934cb49a111c3a580e071beea787247f42d76ffb71eae89093a913be3223420bf4942b18041e8d68e7f222f20bcf38b78fb7ff2d922edc3895a3f543d214004717ed8827ff371f2b721165d6651301856852be46bd7cd8e32d32e5bad0c781dee2e2a5e6a92f5367adbe57a03ff941997d7bee5bc0782b926eaa29a5e43f15fd0ebaa7aee4c1f31bbc42007c21a98c331dedecf89ae8650238b260c2d3419c60f6af6fa6e67db080b247d05addd27fd82d8a09c0e63c8f308da9c0fd2ac7ff6fb63eef594932e8a1160cbefeca9f5929ac122f7395afc436ad6c28eff8fba16aefd66a6dea55764d62c76ed07d8d885d29ec58b29220cd888bf39b0e80e447833f76c447eccc1a70236f1ed847b9b9e0b76a6c80b2f35a6c56339e6f4051521a05f9d1e1d9750d69257948add18e22deaf275ed6f215bbfe3bd347a21b39ff89a278ed0ef374a16040e8536c1a5877d407c903a76cce3726a43b5a6025a92d8153da5239dbf592431f4dfe02d3f66945272e385dd0123329c7c0e2afd5e0a7255b4c351b1de44c747d7151722f9f7a0d85176e69116000d313cf59c1e16d3821b34e6953341ef60c990195aa1caf449ae1bcd7dad6a5775ae95e07fd822e6fd635d407a484a96b991e8d08f84b3ef4aa5a85776171f33f86f4abc22a2487feea5c86068c71e453d5b2c0f510be5e5b22ae375edf78303bf33c22290c7e4d7e049dba4303218f8fb572e903d82264193080f959225ce90977cce213f21028f4e9307e7e372c27bb7d29fd0c9469ca363d75b8bfa2a5f6340be2f985be5f151298368aa0dc9796b23ec54206ab59ef8aef0fcc382769f4091a139386d4e54da3d6eab192ff370bb30b5d2ccb03f5311bcf0b2e07dfd0bbd6afa99be961264e4bcf4840ef13c5a2363795b1a1a9c21b27b701017de6e61a7bfec6bf9978d28b214b1cf6a32a7dbe9a33d6700a30c89be8df8e4f326a3507775de74d501484e3be6d99d83320975f8b3cb9adb9001ae8516b5407a5d1cb9c446090891a9caed3bec45c010954d5a6499af188fd7a10e6021805c010103e344f0ec462cf132f545b57e4354e54eb0fcb844a0401030978112bca017258f0a62041d9ecc2bacd77d86d48c90448ed6baaaaa56415d54240b5a45a4348deda204177c8f87c3f787a23b1b85803a657f6dfd9a2bec7f73a3aac1279d01b5cb90d93de9f6f1210896f4fbffc3bef9ce7300c5602c0fcb5d6bb0a59eff5614a314c572903fd605bc248c133ba554d7a2ff6de227541548baa94c654bc7d615c908a2ced365ae5335db5fd922c2246cd363527ce8710243c6e447462484efacb5f59bf15692aeb3ecdc76f82c19e3b60b161a0e75234c5a76608d5b74e96b090efb0a2afa055402f144074d259ad8c90c022b74242618657e36f5fee8a575311daa98c222ce73a66f847806f129fa3f9b7b6a319ec295f257720bc4ec94013fd33515418fc80983cb6a55f3ff01c739cf341f15f2135f3ee48fe235d09206c5ba44c7ef26314ff9e91ebca84525c6e47f4f7072d8cf4721a8b15eff88017f71dad9165a5161ebe7e5e204f377274b5afabe9c8b5452f84276ef12aa252655301377c47a00520efa431b0f70909ec33e46f3ece0236569c714cee87c074cfd99d46561505b5b7ee4c22d0f615421ab3cfd8cb5d7e73ccc7c43a478da72b9d422eefdc6ac97a369d10b107fe6dba000b6f0920df6a252584b485b1bddfe24bb8e641d6032b52617c719a03035e2d7528feb572ceed47c16ba04e9c72ae4d650df615e7f507805ad7c61db41b66b51d437439eb20d3c631d747d9ba503ff7641db8d3c8e79899bd3b8fbdfc1546289d5c81bb9e15e5e75dd94eb05d59ae9310a84e9ee56b385fbec147ade0e7b3dbdb5eb16c1f80c2f8f798f73f2a7c33cc50139ab06878041b522c6ed71012f76a56f4f3744908570a137d43c74a878c78a411f7918c6b55ea99d1108d9dbc832cc0547a60498675592bce1f03d11d371a6da759252f4ddfd3009e9144bb71968c780499417af4285b4933a891bd63b0c4568acab90143510a2e63997cdb246685a3394fc788e2d7e640c61cd5e6cd9814b2d0ccb12c5045815f10f547919044afdc537a1f6c060ae3553495e2c13ddb1f8248a1c6d4a138c5f52389b073ffa317da45e2fce5bd99c003c62d1129401b516665a8a3c0e607578dfccb80bda7e8c14e7d28cb413ba0760641c09d09f36f98dff252976f0cf4aa1722dd8c427f35eaa45f94c75e3e85d0ee26f5a6bf5ebb4bb66831ee55e791e06bc18f13b4d975c2d9ba2e93751eecdb007b7a34096466d976745319d6e0422ca186b2bd6be08b805a6ee47d948a96e50ce6b2328e506cab1ba0f80e4be2da555b4ae1473eba86533e0cb899d846905be5ddd56cdd40c2d099f27c708eed82b159e135101310b24d4c8ac2d0d97df2835c003470c19e081eed778cec79a427dce883708ed22b546e837263388f7c88d809e94f1fe968a98e48a50ca27aa285d371ae0b6563a1a4abe4409d9a8bf3629af7735053d206fbf58d1390a0bc1d6a20824a69c08820095bb41d52a941f5f520a10a70fccaf00e8bd48aa67b122ff1e947da3ff7b845764f0b5f24d8aec0af5dff7f247d2cd51d8128a892082c8dd4aadebe23a85fa99c1103fc656be38626782de3f30942d6be37566547e58f80451fb0012abcf2c8d29a8837fdb5fedfd7758796d73ff2b3ef637cdf18eda6579734d93847dad7b844da1207dfc27d9fb4c4a32d4f4daeb24303cf9415662bd11b82fab07ffabb9da1422a84073af32def12c8acdba767357c4c8af83b43b916073fb6838c0281038e8143a2b4bd6c894e29a0b65f7505098c35bf6072eebcb088d75d5a141ae8825e79f5939a757acec08dd0dec649f5464bbdb6deee986f35b0fbe0c1e7563e0b33ff415eb29c88c8eed8bf5042db3949b2bce266b9ec25a7d8bef4d4709d9e7fc8e068c0f939e4d6b928c86950411d274bea25944f36381b602b31abc40959fc6f4dee9e98e46ebffb31d976801871db534354be9df02e2e23d016a10993f0ef340943eff426dcaa02c8264c91a294d1a84d6d82e11badd9e4aed1fbb4c64f7be421b7ca48ccfc4f10f53871828004dc8c89a3ed45f27a0e25c3793406547d027125aca210700318c398a76b876e06dcde0f2e70a541403ed62f18e27a6ba472f14fb4f96c2b1cee5ca4b79e5f91218937f80ccf2870be5a0205516f4298866171536bf3147132b15c670d2350ac7e8b1d3500e36cccaff4ebdc6a93261deb9027a141a2586a7e16e2d179f8f531fcec7d40acac1e826304484689dd4001a0da27ec223c3ceddfbca1f1211c2d194e651becb2af21ce527cf6ee3bc5c50b91e1d32c52025defd4d6de889b0cbaa01ee407f5142937f3b88f3afb97118c9f6521a1bd00b1972a5d05f6658c0c03e7abf3c49d63e62f7f13b9fb696e8a321751bff71971152c12ef75ad7e9c203eadcc65949892d015b3737ad3392149face7663ac7e9917407e945625258266257c1ae221fc29d362d84ee8e0f2f40ee8554b7f5de81048f1e8d28b000441322f1394065cf1a616619529f8ba1a3d9ba18cbbe636cf31a5ca9ae2986356205822b64cbc1ba7f1c22092ee1348b76ba045827e819e2f57db64a8158019743a523bfcf06cb6a2c324dd5d02ea8cdc31747df76e93944983a0b62299873b1d691b4e5e1733b680c347f405b90dac7f51d5eaf6959c4640d95df9b5f2e109c33dd2a768613d3dd0b14109f6afbd671e2dced115c101d42e9881a6b86db4ec1b9cbcaa886e25ca01ccb54f58eb2a663e19f78f91860edf3c312b17444e1c1252328a0c35b9dbf002df452f00944fb6137bda64e9dac5073485760e6d673b2b99a4a67ed7431227124ae5ff05f443a52d844aea748ce984ef81677193dcbcb8f88609b53a653c9c344e691a242be0c1868a65facec670c775f9ed909865cb49e0094bd5b2343a47242d838deb2d46666d426c28d2438419d83053fb897e3fcf478d58b96001daa3ac746c0b98c1f7f9af64a3daa7334a6fc4f4ae3edb8594b5ab5c47b2e073550f944b69c07895264feac7dcbf0ed466a8130cfc3ba516af6056813f73637e56ed05e876ba1e49d2678d3057e423d89ccf1c841d039e74cbf8b50bb40af4aedb080609fb1d972eb16805683ad220433263dac3ae1c218f40b1cb8ac0bd6d7495504ef07f30330f5eee6039a5df5bb4b9bf31ff6b12a7dece2350b18782876e7ba95a5f95a9b3c033817d1933428997428401b3de4daa11a5cab9808db1bc75b9dc35c7161719afdc872430f176a2075ee1d4ba97d22341c969d3668df935c3de76916df16a576ee96f9fc9831c5838b13ef7494a587327683f332c4aaa0c92bff63d08aa32961ac582332f05c3b14dc8aa540e78d6459d6802035096bfe3c05d2c6cabb95a72bb00b34cac6f75719fe5a657a3c78af31ec7882c866ed5ee408fe2269ce3f65a440258727be0daa2c38bc1280fc054101e63f800c00bb491dad7ad49ed3ab14fb737669b959020bcc9fc9007c02e10a10676e1aab4ecaeef75c533661e3e857dd2a621f4506dcd85126bc2d122328e11c7e12c367b64a7dd53f54a26c7ded351ae387b5e5b0ee10ec5d2d24c0bde41aa1d0892739ab858b0b7e2ec6e83298aff9bd7d19a0dca07f5712cc0dcc11b5e80e77b7043ea56ff10fe278617128c9574b54ea1f65e962d66d93dbf529197771e145aa9849b6c4cc669c799ac3e3a8c5d9fef2b7137ceae7f27e5914a4a5a44b45256f4f288badc10ad20dd61d85ef397847f0901498e20bae7470da7f84eab4c3e0deaef7de1fca3d712d45b369ada830df66b4321f0d919316881639cf7b85e78dce277cd9590f8367989a582fcbfa4d9be9d0027987add466894b5a1943c4eea609f5f7d8e77d6015e450f624d98ae040ec733c4458f4cdedb34683ffb01fcca2f482e15bee5d30fa3d88efb15a3e36275831dcf1d390a3116b7eefad416bdc6f7152fbc4be0890754f25267875013bb7784d7e4d44764ff30de2f71d6906cfd951167ba455f7b5313b1d00d8da00125e58ba09a77a4a4ea5d5fac0b1806d942a06b6f698a2afa79282ca18e85b66000922e4d917d5365282f5d93196aa55f99598fefcaef7abe2a60767fd8477782bb182bb99245452c05fefa218b267c7a20ad471b28e80b1362ce2fb46806915a49e76c87b3750a988bc3746c6004d1a6f5cabe9361e845366a2a9664e3ee2326e3d75c59ed3d97371d3e5b2dd7a94587e398c1ffb20f37dcf89bb9a1ff2e9633e42a3b61b35fbb941317c8b9088de6dd8f5f715ca900b3923177a1d3c8aa9d2e58a90507a79cbf84a4c5293ce2301f28205e1fd0e9fa47788b109ec5a70ee7fdee5215672da0428c6a1cc363d6817b547c4ba23fa9d5e0b9e275700d7493d5923c256789e3aa0d24cb191c8da9dee6cd0881c7a022e09bba9fafce9d58db82d823481258c6b14c081ce72cb1ef804ae3634790faae6f424b63117aefe339d331679a42780a0f376faf0481682c4861e8ce3ce501d6225bd4e3c1049ff9c1c20e2f890cbf900c99151600009ccb0ac4dfef650ce406f2ac0cba03974880c66dca24e5d6d326d5669ebb4861563ce213d6ae93b250de0ff4d269ac209b571ca1e07bef43f64c138fce368e1f22adf58aa8a265ed108a400e06c0f7b3b25706ab878fb67372274e29f249503d339e87e097114921539e935466c7ed5c67d080e86837d4c0601600dff4d4322c22f4ceb764eca5c35a4df72ca49c6592eb90c5dbd53e597c50ee38884b1c01a6570585e028b227a449115be7520cfd3e6c06a20979f465c51c2492e8a731b3bda9d0ce9b173a28ab66412acecff7b33c81d749365b969fbdbd0f13861ffde95cf5362412f38053511fa8a68180d73cbdaf9536e031e91b03ed0450e80ae70a6d113ff529260990f6695e9a511800de48dc98d2c6d4f33061cf7f05adcac5dd9253b08894e4b84eb2e128e10fcb3cd9e4b446af24733c65021f021653a8057aa75e96dd7303f94fcdae3fa97645e50fded697ef585e3f1c9be7bc9f73b918a6b1886367af56ed3df231466096b411ae9fe469bb875de84fb5078fe58c18649b5633f8d9e23ee0e5e3bd6819238e7a87df71f0bf014a57dcc6296f47731c0b79701bba4c02445f08bcd714b301557d1d2a4989f0618fb2680f1fc001339153914be565dd5fa0c7fe094e323e18c5f85527495af6ddf2430a01c1ac91b4b5d1ec6e64ec59043617890f8467761fbdd5ed8ae2907c2de67961b251567c9fc6baed641c8933537134997abcf3a00728cbfee630ef57bcc2c4b021f5db92c110c55951fe0d042899e5b274733cde7f0f50665d797b3599bee0779d328d19bd96c7c93f135d6c5ad771c9ad2fad69c515a3698978eefcc8341ec707d82f125faee9ae685477caa2e0c55447fecd1272fe86bc8b0a52628f1b6728e06910c95db24ee20d80320c350d67d573a738962207d2702beb8ea1a9f731296658c93f317a8e76795cb1a377d05ee1841f7270e26fc56898107de8983d04434ca57ac0e33dcd5d3def38afd0380c68c51f7a1b23de273fe9a9f0ae1681d377086a40604b135e446f5f546abab8c081b186bc19f8f2fae8a81dfdd61e88e3ec6e12ab579e78c61349d409a1ccfaf748ac4bb5fe0e6f1840deda17481fdafd55998428fd325c9876ea625bf1b8f9dd70599f847c85dff5123bf9d95c086522c4798db6f2399430c9313653a7dbed4107271e41f57ff0e2b9761dd331e5baca4fdde3d92cd291c61c9b111518f5632720cbb0a058c141f3903d91ac98763c0079f30971a91dbcbbacb21aef8522c59e124e8bbbda3369aa1e11738e5b942fca803ce0e7261761cf2419b558e5eecc9fa55623c5b390978c29fe9be5c8dac2bc5796c175ce86b42552138ae07918c69f441e246c17c04f9119fcfe262c8dc2495f2e09f8560fce9645c4776875ba63491d23a51c59edba5b5e7227d7ba28be5f7817318b5ded113acea9c94f9d3a66304dc898b57a6f55236f35d306023038706b7c1f1d360ca2fb2abb92f012693e5bce392275975420328b69a7d77869b4b6f11b594cb4c5cd3b88316c3fc610850d0fb0b4bfcc9fa21951bb6d45eb33135c3b22e0c10cb7f193820b0c7c2e693e230ad4c66cee67e0c1813c11a3fb69f2399508d7a2ec3455c486fe37526df2ee108c24ab65aa27c91a4ae0b750c7740822113b294a39e8f5ca49e5df760ee588123b1b826e7696aa5e828a3c86d8ee6c0e8f67e34daa516fbaaf6d2878dfa4e58b328d458bd06067288ccb00bb8c6e0e5a2e3b50e6a320bdabfc6808b46457d58913ec453a81f197e7514ee2b88e343bf0d22f62333ac5b9621b3a6a0361b536d89c41129f64cc59e18ab11f33974a6a1eb05a94d07898461567fd3fc3252ffabe8559e0951381f9a646e07d842f5bea4a864cbbd6d6ae64bf410c2bbc4c3545ba6c38bf2f63e684203f733bd45d2b580fa7e55faaa35ffa560cc3bf2a88e29ee328184a3574382a20fd55983514e85a11cf13a34aa2c971116740319a000520ca43de0fa74ae7fff57ad6db21dbaa6264b0edadcdba5568935b8f0babc4d9697b3f7b73c7175a7c109f31ceae3293b421c2b8bb9470b891b61f3701676e70bb4c0181922118e0eb03c49819efd833c2396bb7c197f827466f293eb14a7676138ccaff60c5f2f4e6cd56cda6d5deab5f9686e036a2239287c67ac2812a3ed2e8fa109eb9fb3f2529ca483a885c97e7724161cb134ee26fcb18e87afc37055ef90109ac97511622ecb61d51bff6ecba943b785ff8263c63a7800a1a4c78bccab22ff1faa4d62543cdd196cb99ad5f5e273f62fd505c3ca710ddd478c7612826543f3ef8c1acc5dfd2c7358d558db365116f07953f067f4eb87930bb165681f82b5252a29a5e09dae770a29a6dbc84fbc403623a62184b135f5ff58c2421b0d5fe618a1608dedeba848d8e6b5c8275ff9ed5d6f45e9acd9f848296200fd9bd9061dd13344adb6e8dcf7c216243ec136404cd247998853d651cef7213738c9e0d215f31d95fc74b6995583f592725d11e3eaebf420dacf1d95afe0745475bcb09e0fda06552a6eac3c2061044cc8cd5c3776fe1affc644c372328974e86963b05fac56d014781732862e2a53976aaa28785b13c6c4619ada6d41055c2a6dacfa794ebbeb85cdb589e5bda16038ff21deafb7938f5f2b23870b732d74e29cf7aa3b5f3dd73a6a8e76c2d4c22a1acebc536b47408a28aab7b9103d030d4bbbbb65d3ebb274bbbabca59a3d12fd9470376558e91791108bd95c4797184fe360390b3a7671d24e6d32e3350034f737526eff8f52b763282a3a20eef08ef50f91891a65fb5c7316e330c8ee893ad3b2c5cfd32c48eea4767dea70fbc6b6aa98e7797abce665c368032610e7edc9f520ad03979f8a0742b1602e35168d903da40601af11ea5576f729980490bcfadd975f5a24874c9585886dea92a498eaac452139808142d2f4f1e068363d24c0e9b7a5843f240a51f1e3a372010a9da84564ac5f1f72221f5cdf611080c9acdc6b630dd57cddb25d356886b656fa093a93a280c9f5bac55adfa6c721268be10e32ea3dafe507500d874ffb735a6290dde48ce4319cc4f770228293c88821e604b5472af2dfeaa97c18d3c7c4ae5d773ad87a5045973f82b7aa97097b79c482108db53ffb7da6d61a821d2dd9036b3cc5614fa08c3efd3df13ff400ef60d6541b9dda3b2d01ae482f1bfe624d8c8548651dc43b1c04c020dcbffd864ff66fc69a933b5813a1937982ebd5cce94ed5b95e0215653d3c66ed166614e84d05fd72a6a3b8342f71dc04b1aa4d8f5a9ac703036f602182724999efa86809ef9415e5a9e946256448b6ce65d2d13418f1273113e869c8ac0e9c434fe8709b38ace3a7c9a17d68cf1d2106fc302031165194a95e80 Hey, password is required here.]]></content>
      <categories>
        <category>经济</category>
      </categories>
      <tags>
        <tag>加密货币</tag>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021届秋招经验总结]]></title>
    <url>%2F2021%2F04%2F03%2F2020%E7%A7%8B%E6%8B%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言前段时间因忙于搞定毕业答辩、离校手续相关的事情，使得这篇经验贴酝酿过久，几乎过了保质期。趁此清明节之际，将去年求职的经验稍作梳理，以飨读者，希望能对求职路上的小伙伴们有所帮助。 本人是CS专业，故言语站位上难免偏向本专业视角，不过有些应对思路和其他专业未必不存在共性，因此本文主要从两个角度出发：其一是共性的个人管理，主要分享一些时间管理的节奏、资料管理的技巧和人脉管理的思路；其二是我参与秋招的两个行业及相关岗位作为具体的案例穿插在宏观的应对思路中进行叙述，一是互联网，主要投递的是算法岗，基本上目标范围内的公司都拿到了SP offer ; 二是体制内的岗位，这里也可以分为两块，第一块是事业单位的人才引进，第二块是选调生，由于和选调生考试面试以及毕设提交时间段重叠严重，因此人才引进我只参与了一场, 选调生主要参加了浙江选调和中央选调。 正餐篇本章主要分享在求职准备过程中的一些宏观的思考并结合具体行业做详细说明。 每年招聘季的大致时间是可以确定的，而且这里也存在一个马太效应，如果能拿到好的实习，就能够利用好的实习撬动好的秋招offer； 如果能拿到好的秋招offer，就能argue到更高的package，最后你会发现，拿了一大把优质Offer的总归是那么几个大佬，相信这类“卷法”大家已经在评奖评优的过程体会过了。因此，从找实习开始，时间节奏就非常重要。 时间管理 我的整个求职过程持续了漫长的一整年，这其实是本人过于贪心或者说是对未来还比较迷茫所致，对于规划特别明确或者对特定行业特别热爱的同学来说，大半年时间足矣，无需把自己折腾的太累，将这份时间规划拆分成两半来看即可（互联网 2019.11 - 2020.09， 体制内 2020.06 - 2020.12，此时实习应替换成政府单位）。 下面详细展开一些各阶段的注意事项： 2019年11月 - 2020年01月 刷题：一般研二秋学期末就要开始刷Leetcode了，刷题的时候不需要太在意数量，重要的是要总结题型以及对应使用的数据结构和算法，做到一看到题目就能大概猜到要用什么类型的DS，一般刷完前200 ~ 300经典题就足矣了，同时把剑指offer的题库也刷一遍。这里推荐大家把国内站和海外站结合起来使用，海外站的讨论区质量高，国内站的活动多，刷起来不会枯燥 2020 年 1 月 - 2020 年 2 月末 面试准备：这两个月要开始训练做题的速度和准备面试的内容， 看面经和书：对于算法岗，一般过一遍李航的《统计学习方法》和 hulu的《百面机器学习》（后面新出了一本《百面深度学习》）就可以了，主要还是要结合面经来总结常见基础问题的答案，当时主要是 @常委 总结了一份面经和兄弟们分享了一下，部分目录如下，小伙伴们可以根据自己的需求总结自己的文档： 打周赛：leetcode 每周末都会组织两场周赛，而且在求职季的时候会和公司合作，优胜者能获取奖品和内推码。 周赛主要用来训练思维的敏捷度和提高编码的熟练度，一般在面试前达到半小时内 kill 前三题就可，第四题有时候会出现奇行种，做不出也挺正常。 总结自己的项目：有paper的讲paper，有项目的讲项目，有比赛的讲比赛，不用太多，核心原则就一个——放在简历里的是要和投递岗位最匹配的，要突出项目的亮点和难点以及你在其中扮演的角色，描述过程可以参考著名的STAR法则，同时也可以找个同学来当模拟面试官，互相评估面试过程中的不足。 2020年3月 - 2020年四月 投递实习：这个时间段是几家公司集中招聘实习生的时期，出手要果断，以战代练，不要抱有一种“我准备好了才去投递”的心态，相信我，永远没有一个时刻是完全准备好的；如果心里还是发虚，就找一些小公司先练练手，练完了再把握大公司的提前批，善于反过来利用面试官来完善自己的简历和面试回答。此外，建议建立一个表格来追踪各个公司的进度，这里给一个自己的样例。 2020年5月 选offer: 这个月相对来说会轻松一些，手头也有了一些offer，但是选offer时候还是要三思，不要只看实习工资，还是要结合自己未来的发展城市、小组的前景等等综合考虑，此时多考虑一步就能为秋招省下很多精力。 2020年6月 毕设开题：有些同学会在这个时间段提前去实习，不过因为我后面还要参加体制内的求职，此时去实习必然赶不上3月份的毕业，会对后面的心态造成不利影响，因此这个月我主要做了一些毕设方向的文献调研，基本确定了算法框架和实验思路。 2020年7月 - 2020年9月初 暑期实习及秋招面试：这个时间段我在蚂蚁实习，亲身体会了巅峰的辉煌，和后面的急速坠落相比，真的是世道沧桑。一般这个时候会有一个带你的师兄，不要单纯地完成他给你的任务，要主动地向他请教目前的工作处在业务中的什么位置，与做研究一样，文献综述的目的之一就是找到自己工作在领域big picture中的定位，这么做的目的一是赋予你工作价值感，同时帮助你判断业务在公司中的前景，二是方便你在转正答辩时介绍自己的工作，三则是方便后面包装简历中的项目经历。 一般8月中下旬各个公司都会开始转正答辩，好好把握这个机会，争取在正式秋招开始前就能拿到保底offer。 支线求职：有些公司还会以夏令营的形式来招聘，如招行（包吃包住包交通还有奖金，3天深圳游）、字节跳动（封闭式课程+实践项目）等等。 题外话：最近招行的夏令营开始招聘了，有兴趣私信我帮你内推。 2020年 9月 - 2020年11月初 互联网落幕 体制内登场：8月到9月中旬这段时间里互联网主力的秋招也基本结束，后面大多是谈薪等事务了，此时我的重心也渐渐转向了体制内的工作。9月初陆续有面向应届生的人才引进项目了，去年较早的有宁波、绍兴等地，当时抱着去熟悉一下考试形式的心态未作任何准备就去面试宁波的项目了，一不小心就拿到了offer。总的来说，考察内容比选调生“水”一些，适合作为另一层次的保底offer。除此之外，选调的笔试和毕设的实验也要启动了，因为做的是cv相关的东西，跑实验的时候就可以看各种考公资料，并行处理来争取时间。 2020年 11月 选调生笔试：本人主要参加了两场选调生考试，浙江选调（11.15）和中央选调（11.29 和国考一致），两者相差半个月左右，对我来说这个时间并不算特别舒服，中间隔了半个月，好不容易练起来的做题手速凉了一半；同时继续积累毕业论文所需的实验数据。 2020年 12月 完成毕设： 由于今年选调卷爆炸的形势和自己的失误，两场选调的笔试均以毫厘之差的失败而告终，至此整个秋招基本结束，后续便将重心移至毕业论文的撰写上。 信息管理网络上现在关于求职的信息多如牛毛，很多情况下需要我们进行过滤和归档，因此我们也需要对繁杂的信息进行管理，本节会分享一些常用的信息渠道、经验资料和管理工具。 互联网 求职信息渠道：牛客网、微信群、学校就业网、CC98、脉脉、领英、朋友圈（很多人可能平时是关闭的，建议求职期间开启）、知乎、github、各个企业官网 经验资料： 笔试资源： leetcode题解博主：花花酱 happygirl cat racket acwing 闫学灿 leetcode 题目分类列表 算法oi: https://github.com/OI-wiki/OI-wiki/ 我自己总结的算法模板（Python）： https://www.zhihu.com/people/mason-21/posts 面试资料：不同岗位的面经不同，没有统一的方案，最好是自己总结一份文档，这里给出常用的算法岗的参考资料，可能在前文中出现过。 书籍：《百面》系列，《统计学习方法》 视频： b站白板推导系列 博客： 海量数据系列 论坛：在牛客上搜索对应公司的面试消息 管理工具： 笔记汇编：推荐onenote和有道云，前者可以通过onedrive在多平台上同步，且配合chrome插件clip to onenote 很容易实现对网页的剪贴；后者可以通过微信进行网页的剪贴。两者都无设备数的限制。 链接存储：很多时候我们看到一份资料很棒，但是又没时间一次性看完，或是几个资料间重合度较高，想要先存起来待后续整理，这时就需要一个临时存放链接的工具，这里推荐pocket，pc端可以利用chrome的插件，移动端也有app。 代码分享：某些时刻需要阅读一些小片段的代码，可以用到一个工具网站 https://paste.ubuntu.com/ 进行格式上的美化，不必再重新保存成文件了。 体制内 资格核对： 一般三大项：中共党员（含预备党员）、校级荣誉（“三好”学生、校级优秀毕业生）、具有相应层级学生干部经历1学年以上，其中浙江选调是”或“关系，江苏和央选是”与“关系。 经历积累： 学生干部经历：班干部（班长，团支书）或党支书 学生组织：基协、紫领 培养计划：各学院青马工程（计算机学院是熔金计划） 单位实习：公管学院面向全校的”青知计划“ 岗位信息渠道： 网站 浙江大学就业指导网与服务中心：http://www.career.zju.edu.cn/ ， 浙江人事考试网：http://www.zjks.com/ 高校人才网：http://www.gaoxiaojob.com/ 公众号/小程序 浙大基协 紫领人才俱乐部 粉笔上岸通 辅导员、同学、微信群 中央选调一般是辅导员通过党支部通知，每个学院有名额，还要上报学校审批，有意向的同学可以提早和老师沟通。 经验资料： 笔试： 行测: fb 980系统地刷一遍，主要是练习资料分析的速算和数量关系的估算。对于选调我其实不建议大量的刷模拟题，一是题目的质量无法保证，二是近年来题目（浙选、国考）难度持续拉升，往年的题目水平已经不具备太大的参考价值。 申论： 做真题，结合 半月谈、申论查等app综合比较答案 对应省份的省委书记讲话稿，主要看一下在任时的发展战略。 半月谈 《申论素材宝典》 人民网时评 面试：本人并未入围两地的面试，这里取成功者经验，各位看官姑且一观。 不建议各种费用昂贵的培训班，玩的就是概率。 最有效的方法——微信互助：和小伙伴建群约定时间进行线下模拟练习，各自找一个题目，对方帮忙计时并且点评，提出修改建议。 紫领会组织已经上岸的学长分享经验 演讲的技巧： How to speak Make Body Language Your Super Power 辅助工具： 资料整理工具同上一小节互联网处一致 讯飞有声app：可以将文字内容转成语音，这样就可以利用吃饭、通勤等碎片时间积累素材，同时解放眼睛。题外话：英文文献可以利用ivona TTS 引擎 + natural reader听读。 Anki: 辅助记忆的工具，可以制作一些面试卡片，训练自己的反应力。 很多前辈的经验分享珠玉在前，这里补充两个超详细的求职攻略，细节上的准备过程本文就不再重复造轮子了（内网可访问）： IT业：@冰冰的小冰 https://www.cc98.org/topic/4905157 体制内：@马甲咿呀 https://www.cc98.org/topic/4914295 人脉管理求职切忌“单打独斗”，求职笔面并不是闭卷考，因此要充分利用师门前辈和同届校友的资源，尽可能的抹平和公司的信息差，一般的，大多数同学能够接触到人脉资源可分为五个类型： 同门师兄师姐（前提是师门画风和谐）：掌握着公司内部的一手信息，且一般非常乐意帮助下一届。 同届小伙伴：共享信息，一人面试，多人受益。 校友：包括各类在校内发布内推的前辈，这类较为鱼龙混杂，有无私分享的，也有只看重内推奖励的，还有直接贩卖焦虑割韭菜的。 企业HR / 组织部或人社局工作人员： 通过这类人能够获得官方公开的消息，但基本不可能获得隐藏的额外信息。 公网上的陌生人：有很多公司的员工会直接把内推码挂在牛客等论坛上，不建议利用这个渠道，个人信息给了陌生人倒是其次，主要是如果后续无法联系上他就相当于无法追踪你在这个公司的进度，浪费了一次机会。 根据不同的专业和投递的行业，选择不同类型的人脉作为基本盘： 如，本人专业是CS，对于互联网来说根正苗红，因此主要依靠前两个类型的人脉，这是专业优势；但一旦求职方向转换为体制内，就只能依靠校友和少量同届小伙伴了，此时就要借助学校平台的力量，多参加上一节”经历积累“中提到的组织和活动来结识同道中人。 结语按照原本的计划，我是想互联网和选调两手抓的，奈何对选调变“卷”的加速度估计不足，导致最后准备笔试的时间还是有所不足，事后诸葛亮一下，应该从暑假就开始看一些应试的资料，这样加上9、10两个月份就可以更加宽裕、并行地撰写毕业论文；或者就是要有破釜沉舟地勇气，选择直接延毕，我周围也有这样成功上岸的同学。从整体的趋势看，CS专业在选调中热门程度有所下降，以浙江省为例，19届的优质岗位主要是省级单位，20届的主要是市级单位，而我们这一届主要是区县级和公安局，计算机相关的体制内岗位在逐渐饱和，如果你是CSer的话也建议也先找个保底的互联网offer，因为到时候不一定有想报的岗，而且我们这一届很多省开始把好岗位作为提前批单独给了清北，这一点也需要一并考虑。 人才引进的话岗位倒是目前来看挺充裕的，不过有些待遇好的地区有些岗位要求博士了（就紧接着我的下一批），每年的政策也都在变化。 考公的话，总体的趋势是岗位往应届生倾斜，也就是选调生普通gwy化，公考职业老油条神仙打架化。所以如果大家想进入体制内的话，还是要早早做抉择，利用好应届生的优势。 致谢最后，感谢一下提供各种帮助的师兄师姐、校友前辈们和 在互联网赛道上一起奋斗过的小伙伴们： @ 鸽王 @ 黄老板 @final马 @常委 @纬爷 在体制内道路上一起奋斗过的小伙伴们： @孟主任 @许书记 最后， 祝各位22届小伙伴求职顺利~ 最最后，如果大家有任何求职的疑问（互联网、体制、转行）都欢迎私聊，lz尽力回答，能力范围之外也可以邀请认识的好友代答，最近应该还会在学校里苟一会~ Q&amp;A这里选取部分常见的问题做一下统一的回答，方便大家阅读。 Q: 半小时kill3题也太难了吧 现在基本上只能做出来两道是不是没救了？ A: 一般45分钟3道题也行的，一般一场1小时的面试，前面30到40分钟会问你基础知识和项目，后面的时间做1~2道题，10几分钟写道题还是比较正常，主要是要理清思路，多和面试官沟通自己的思路，实在做不出的话，nice一点的面试官会给提示的，而且一般不会出hard题，出了也是经典题，出怪题可以去举报面试官了hhh（应该就是故意挂人） Q: 【私信】本科不是浙大的，请问会不会卡学历？ A: 现在有浙大学历肯定符合学校要求，但是本科的荣誉和学生干部经历只有当 本科学校也在选调范围内时才作数，否则只能用在浙大时取得的荣誉和干部经历。 Q: 想问下海外高校去选调，是不是机会比较少呀？ A: 人才引进是包含了海外高校的, 招录公告会明确范围；选调的话挺少的，这里截取了知乎一个答案的给大家参考： 截止2021年1月，目前有面向海外定向选调政策的省市包括： 8个省/直辖市：四川、重庆、河南、广东、黑龙江、河北、北京、山东。 2个城市：长春、青岛。 Q: 【私信】这种人才引进是不是首先有限制一定的专业，然后人才引进的面试流程具体形式会是怎样的呀？然后宁波下面不同地区人才引进是不是分开招的呀？证明一个地区没有上还能有机会申别的地区嘛？ A: 对，是分岗位招的，每个岗位有对应的专业限制，像我就是信息技术 面向计算机类的， 其他还有经济管理、综合管理、建筑工程等； 面试流程的话，宁波是先写个申论作为笔试，当天晚上通知是否进面，第二天早上直接进行结构化面试，然后招聘的时候各个区是统一的，你只能选一个区报，一个区没上也没有机会申别的区了。 Q: 那请问浙大本科期间做过班级委员也算符合要求吗？ A: 一般要求班委以上 保险的：班长（副班长）、团支部书记（副书记） 生活委员、学习委员等职务一般不界定为学生干部，实际请咨询辅导员或就业办老师。]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题美化]]></title>
    <url>%2F2021%2F02%2F05%2Fhexo%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[hexo美化之添加live2d动画1.hexo博客文件目录下安装live2D插件1bashnpm install --save hexo-helper-live2d 2.下载live2D动画模型动画选项及对应效果展示 live2d-widget-model-chitoselive2d-widget-model-z16live2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01live2d-widget-model-haru/02live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wanko 安装示例 1npm install live2d-widget-model-tororo 3. 修改配置文件_config.yml123456789101112131415161718192021# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true #隐藏/显示 pluginRootPath: live2dw/ #插件在站点上的根路径(相对) pluginJsPath: lib/ #与插件根目录相关的JavaScript路径(相对) pluginModelPath: assets/ #与插件根(相对)相关的模型路径 scriptFrom: local # Default # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # Your custom url tagMode: false #是否只替换live2d标签而不是注入到所有页面 log: false #是否在控制台显示日志 model: use: live2d-widget-model-wanko #安装的模型包名称 display: #设置位置和宽高（设置的宽高*2为实际像素，如：50=100px） position: right width: 200 height: 400 mobile: show: false #是否在移动端上显示 参考资料： https://www.guoxh.com/blog/2019/03/15/hexo%E9%9B%86%E6%88%90live2D%E5%8A%A8%E7%94%BB/ hexo美化之右上角添加fork me on github入口1.首先到GitHub Corners或者GitHub Ribbons选择自己喜欢的图标，然后copy相应的代码 2.然后将刚才复制的代码粘贴到themes/next/layout/_layout.swig文件中&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 下面一行 3.把代码中的href后面的值替换成你要跳转的地址，比如你的GitHub主页 参考资料： https://blog.csdn.net/mqdxiaoxiao/article/details/93796367 hexo美化之添加侧边社交链接在配置文件theme文件夹中的_config.yaml中添加 12345678social: GitHub: https://github.com/Po***** || github E-Mail: mailto:113***@qq.com || envelopesocial_icons: enable: true icons_only: false transition: false 参考资料： https://benpaodewoniu.github.io/2020/03/08/hexo21/ https://cloud.tencent.com/developer/article/1577027（较为全面）]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网笔试常用数据结构与算法总结(python 模板)]]></title>
    <url>%2F2021%2F02%2F05%2F%E4%BA%92%E8%81%94%E7%BD%91%E7%AC%94%E8%AF%95%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-python-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[常用数据结构和算法模板（python）经典1.埃拉托斯特尼筛法1234567891011121314151617181920212223def countPrimes(n): ''' 输出 &lt;= n 的质数个数 :param n: 整数 :return: 质数个数 ''' if n &lt; 2: return 0 isPrime = [True] * (n + 1) isPrime[0] = isPrime[1] = False i = 2 while i * i &lt;= n: if isPrime[i]: for j in range(i*i, n+1, i): isPrime[j] = False i += 1 cnt = 0 for flag in isPrime: if flag: cnt += 1 return cnt 参考习题 https://leetcode-cn.com/problems/count-primes/, 答案如下，和模板略有区别： 123456789101112131415161718192021222324class Solution: def countPrimes(self, n: int) -&gt; int: ''' 返回小于 n 的质数个数 :param n: :return: ''' if n &lt;= 2: return 0 isPrime = [True] * (n) isPrime[0] = isPrime[1] = False i = 2 while i * i &lt; n: if isPrime[i]: for j in range(i*i, n, i): isPrime[j] = False i += 1 cnt = 0 for flag in isPrime: if flag: cnt += 1 return cnt 2. 快速幂1234567891011def myPow(x: float, n: int) -&gt; float: res = 1.0 base = x e = abs(n) while e: if e &amp; 1 == 1: res *= base base *= base e &gt;&gt;= 1 return res if n &gt;= 0 else 1.0 / res 练习题：https://leetcode-cn.com/problems/powx-n/ 12345678910111213141516class Solution: def myPow(self, x: float, n: int) -&gt; float: def quick_pow(x, n): base = x ans = 1 while n: if n &amp; 1: ans *= base base *= base n &gt;&gt;= 1 return ans return quick_pow(x, n) if n &gt; 0 else 1/quick_pow(x, abs(n)) 3. 大数模拟大数加法练习题：leetcode 415 https://leetcode-cn.com/problems/add-strings/ 123456789101112131415def addStrings(self, num1: str, num2: str) -&gt; str: ''' 大数加法 ''' res = "" i, j, carry = len(num1) - 1, len(num2) - 1, 0 while i &gt;= 0 or j &gt;= 0: # 高位补零 n1 = int(num1[i]) if i &gt;= 0 else 0 n2 = int(num2[j]) if j &gt;= 0 else 0 tmp = n1 + n2 + carry carry = tmp // 10 res = str(tmp % 10) + res i, j = i - 1, j - 1 return "1" + res if carry else res 大数乘法练习题：leetcode 43 https://leetcode.com/problems/multiply-strings/ 1234567891011121314151617181920def multiply(num1, num2): product = [0] * (len(num1) + len(num2)) # placeholder for multiplication ndigit by mdigit result in n+m digits position = len(product) - 1 # position within the placeholder for n1 in num1[::-1]: tempPos = position for n2 in num2[::-1]: product[tempPos] += int(n1) * int(n2) # ading the results of single multiplication product[tempPos - 1] += product[tempPos] // 10 # bring out carry number to the left array product[tempPos] %= 10 # remove the carry out from the current array tempPos -= 1 # first shifting the multplication to the end of the first integer position -= 1 # then once first integer is exhausted shifting the second integer and starting # once the second integer is exhausted we want to make sure we are not zero padding pointer = 0 # pointer moves through the digit array and locate where the zero padding finishes while pointer &lt; len(product) - 1 and product[ pointer] == 0: # if we have zero before the numbers shift the pointer to the right pointer += 1 return ''.join(map(str, product[pointer:])) # only report the digits to the right side of the pointer 计算进位： 计算 carry = tmp // 10，代表当前位相加是否产生进位；添加当前位： 计算 tmp = n1 + n2 + carry，并将当前位 tmp % 10 添加至 res 头部；索引溢出处理： 当指针 i或j 走过数字首部后，给 n1，n2 赋值为 00，相当于给 num1，num2 中长度较短的数字前面填 00，以便后续计算。当遍历完 num1，num2 后跳出循环，并根据 carry 值决定是否在头部添加进位 11，最终返回 res 即可。复杂度分析： 时间复杂度 O(max(M,N))O(max(M,N))：其中 MM，NN 为 22 数字长度，按位遍历一遍数字（以较长的数字为准）；空间复杂度 O(1)O(1)：指针与变量使用常数大小空间。 4. GCD12345678def gcd(a, b): ''' 这里不用判断a, b的相对大小,如果 a &lt; b, 在递归调用 gcd(b, a%b)时 自动调换了顺序。 ''' if b == 0: return a return gcd(b, a % b) 参考习题：https://leetcode-cn.com/problems/simplified-fractions/，最简分数，gcd的应用 12345678910111213class Solution: def simplifiedFractions(self, n: int) -&gt; List[str]: def gcd(a, b): if b == 0: return a return gcd(b, a % b) res = [] for i in range(2, n+1): for j in range(1, i): if gcd(j, i) == 1: res.append(str(j) + '/' + str(i)) return res 5. LCM (最小公倍数)12def lcm(a, b): return a * b // gcd(a, b) 7. 二分搜索万能模板 12345678910111213141516171819202122# 当分支逻辑不能排除右边界，选左中位数，如果选右中位数则会出现死循环def binary_search1(left, right): while left &lt; right: mid = (left + right) &gt;&gt; 1 if check(mid): left = mid + 1 else: right = mid # 退出循环的时候， 视情况，是否需要单独判断left是否满足条件 return leftdef binary_search2(left, right): while left &lt; right: # 选择右中位数 while left &lt; right: mid = (left + right + 1) &gt;&gt; 1 if check(mid): right = mid - 1 else: left = mid # 退出循环的时候， 视情况，是否需要单独判断left是否满足条件 return left 8. 并查集12345678910111213parent = list(range(N))def find(x): if x != parent[x]: # 路径完全压缩 parent[x] = find(parent[x]) return parent[x]def union(x, y): root1 = find(x) root2 = find(y) parent[root2] = root1 类形式： 123456789101112131415161718class DSU: def __init__(self, N): self.parent = list(range(N+1)) self.edges = 0 def find(self, x): if x != self.parent[x]: # 路径完全压缩 self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): root1 = self.find(x) root2 = self.find(y) self.parent[root2] = root1 self.edges += 1 图论9. 最小生成树(贪心思想)解析 花花酱：https://www.youtube.com/watch?v=wmW8G8SrXDs 图论500 题 https://blog.csdn.net/luomingjun12315/article/details/47438607 Kruskal算法 主体部分如下，需要用到并查集（下面完整测试案例中会给出） 1234567891011121314def kruskal(): ''' 适用于求稀疏图 :return: 最小生成树的边和 ''' cost = 0 for u, v, w in sorted(edges, key=lambda x: x[2]): pu, pv = find(u), find(v) if pu == pv: continue # 等同于union parent[pu] = pv cost += w return cost leetcode中缺少相关的习题，固用花花酱视频中的例子测试了一下： 123456789101112131415161718192021222324252627282930313233n = 4edges = [[0, 1, 1], [0, 3, 3], [0, 2, 6], [2, 3, 2], [1, 2, 4]]parent = list(range(n))def find(x): if x != parent[x]: # 路径完全压缩 parent[x] = find(parent[x]) return parent[x]def union(x, y): root1 = find(x) root2 = find(y) parent[root2] = root1def kruskal(): ''' 适用于求稀疏图 :return: 最小生成树的边和 ''' cost = 0 for u, v, w in sorted(edges, key=lambda x: x[2]): pu, pv = find(u), find(v) if pu == pv: continue # 等同于union parent[pu] = pv cost += w return cost Prim算法 12345678910111213141516171819202122def prime(): ''' 适用于稠密图，堆优化版本 :return: cost ''' q = [] cost = 0 seen = set() # push a dummy node, (cost, node) heappush(q, (0, 0)) for _ in range(n): w, u = heappop(q) if u in seen: continue cost += w seen.add(u) for v, w in graph[u]: if v in seen: continue heappush(q, (w, v)) return cost 测试代码： 123456789101112131415161718192021222324252627282930313233343536from collections import defaultdictfrom heapq import *n = 4 # 顶点数edges = [[0, 1, 1], [0, 3, 3], [0, 2, 6], [2, 3, 2], [1, 2, 4]]graph = defaultdict(list)for e in edges: graph[e[0]].append((e[1], e[2])) graph[e[1]].append((e[0], e[2]))def prime(): ''' 适用于稠密图，堆优化版本 :return: cost ''' q = [] cost = 0 seen = set() # push a dummy node, (cost, node) heappush(q, (0, 0)) for _ in range(n): w, u = heappop(q) if u in seen: continue cost += w seen.add(u) for v, w in graph[u]: if v in seen: continue heappush(q, (w, v)) return costprint(prime())# 6 最短路算法合集统一习题：LC743 https://leetcode-cn.com/problems/network-delay-time/ 最短路算法的分类： 单源最短路 所有边权都是正数 朴素的Dijkstra算法 O(n^2) 适合稠密图 堆优化版的Dijkstra算法 O(mlog n)（m是图中节点的个数）适合稀疏图 存在负权边 Bellman-Ford O(nm) spfa 一般O(m), 最坏O(nm) 多源汇最短路 Floyd算法 O(n^3) 参考代码：https://leetcode.com/problems/network-delay-time/discuss/283711/python-bellman-ford-spfa-dijkstra-floyd-clean-and-easy-to-understand 11. 迪杰斯特拉算法单源最短路 所有边权都是正数 朴素的Dijkstra算法 O(n^2) 适合稠密图 堆优化版的Dijkstra算法 O(mlog n)（m是图中节点的个数）适合稀疏图 123456789101112131415161718192021222324def dijkstra(graph, source, N): ''' 单源最短路径算法 :param graph: 邻接矩阵，或者用字典实现 :param source: 起始点 :param N: 节点个数 :return: ''' # 如果是node 是 1-indexed dist = [float('inf')] * (N + 1) prev = [-1] * (N + 1) dist[source] = dist[0] = 0 hq = [(0, source)] while hq: d, u = heapq.heappop(hq) for v in graph[u]: alt = dist[u] + graph[u][v] if alt &lt; dist[v]: dist[v] = alt prev[v] = u heapq.heappush(hq, (alt, v)) return dist, prev 习题解答： 123456789101112131415161718192021222324252627282930313233343536class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: # construct graph graph = collections.defaultdict(dict) for u, v, time in times: graph[u][v] = time def dijkstra(graph, source, N): ''' 单源最短路径算法 :param graph: 邻接矩阵，或者用字典实现 :param source: 起始点 :return: ''' dist = [float('inf')] * (N + 1) prev = [-1] * (N + 1) # 如果是node 是 1-indexed dist[source] = dist[0] = 0 hq = [(0, source)] while hq: d, u = heapq.heappop(hq) for v in graph[u]: alt = dist[u] + graph[u][v] if alt &lt; dist[v]: dist[v] = alt prev[v] = u heapq.heappush(hq, (alt, v)) return dist, prev dist, _ = dijkstra(graph, K, N) # print(dist) ans = max(dist) return ans if ans != float('inf') else -1 Bellman-Ford 算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Python3 program for Bellman-Ford's single source# shortest path algorithm.# Class to represent a graphclass Graph: def __init__(self, vertices): self.V = vertices # No. of vertices self.graph = [] # function to add an edge to graph def addEdge(self, u, v, w): self.graph.append([u, v, w]) # utility function used to print the solution def printArr(self, dist): print("Vertex Distance from Source") for i in range(self.V): print("&#123;0&#125;\t\t&#123;1&#125;".format(i, dist[i])) # The main function that finds shortest distances from src to # all other vertices using Bellman-Ford algorithm. The function # also detects negative weight cycle def BellmanFord(self, src): # Step 1: Initialize distances from src to all other vertices # as INFINITE dist = [float("Inf")] * self.V dist[src] = 0 # Step 2: Relax all edges |V| - 1 times. A simple shortest # path from src to any other vertex can have at-most |V| - 1 # edges for _ in range(self.V - 1): # Update dist value and parent index of the adjacent vertices of # the picked vertex. Consider only those vertices which are still in # queue for u, v, w in self.graph: if dist[u] != float("Inf") and dist[u] + w &lt; dist[v]: dist[v] = dist[u] + w # Step 3: check for negative-weight cycles. The above step # guarantees shortest distances if graph doesn't contain # negative weight cycle. If we get a shorter path, then there # is a cycle. for u, v, w in self.graph: if dist[u] != float("Inf") and dist[u] + w &lt; dist[v]: print("Graph contains negative weight cycle") return # print all distance self.printArr(dist)g = Graph(5)g.addEdge(0, 1, -1)g.addEdge(0, 2, 4)g.addEdge(1, 2, 3)g.addEdge(1, 3, 2)g.addEdge(1, 4, 2)g.addEdge(3, 2, 5)g.addEdge(3, 1, 1)g.addEdge(4, 3, -3)# Print the solutiong.BellmanFord(0)# Initially, Contributed by Neelam Yadav# Later On, Edited by Himanshu Garg 123456789class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: dist = [float("inf") for _ in range(N)] dist[K-1] = 0 for _ in range(N-1): for u, v, w in times: if dist[u-1] + w &lt; dist[v-1]: dist[v-1] = dist[u-1] + w return max(dist) if max(dist) &lt; float("inf") else -1 12. spfa判断有无负环：如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图，但是可以判断是否出现负权环） 1234567891011121314151617class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: dist = [float("inf") for _ in range(N)] K -= 1 dist[K] = 0 weight = collections.defaultdict(dict) for u, v, w in times: weight[u-1][v-1] = w queue = collections.deque([K]) while queue: u = queue.popleft() for v in weight[u]: if dist[u] + weight[u][v] &lt; dist[v]: dist[v] = dist[u] + weight[u][v] queue.append(v) return max(dist) if max(dist) &lt; float("inf") else -1 13. Floyd-Warshall12345678910def floyd_warshall(graph, N): ''' :param graph: 邻接矩阵 :param N: 节点数 :return: 修改过的邻接矩阵 ''' for k in range(N): for i in range(N): for j in range(N): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) 习题答案： 12345678910111213141516171819202122class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: # construct graph dist = [[float("inf") for _ in range(N)] for _ in range(N)] for u, v, w in times: dist[u - 1][v - 1] = w for i in range(N): dist[i][i] = 0 def floyd_warshall(graph, N): ''' :param graph: 邻接矩阵 :param N: 节点数 :return: 修改过的邻接矩阵 ''' for k in range(N): for i in range(N): for j in range(N): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) floyd_warshall(dist, N) return max(dist[K - 1]) if max(dist[K - 1]) &lt; float("inf") else -1 二分图14. 染色法123456789101112131415161718192021222324252627282930import collectionsdef isBipartite(graph): n = len(graph) UNCOLORED, RED, GREEN = 0, 1, 2 color = [UNCOLORED] * n # graph 不一定是连通图 for i in range(n): if color[i] == UNCOLORED: q = collections.deque([i]) color[i] = RED while q: node = q.popleft() cNei = (GREEN if color[node] == RED else RED) for neighbor in graph[node]: if color[neighbor] == UNCOLORED: q.append(neighbor) color[neighbor] = cNei elif color[neighbor] != cNei: return False, None return True, colorgraph = [[1,3], [0,2], [1,3], [0,2]]print(isBipartite(graph))'''(True, [1, 2, 1, 2])''' 15. 匈牙利算法 (用于寻找最大匹配)讲解：https://www.renfei.org/blog/bipartite-matching.html https://blog.csdn.net/dark_scope/article/details/8880547 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class DFS_hungary(): # https://www.icode9.com/content-1-615590.html # 参数初始化 def __init__(self, set_A, set_B, edge, cx, cy, visited): self.set_A, self.set_B = set_A, set_B # 顶点集合 self.edge = edge # 顶点是否连边 self.cx, self.cy = cx, cy # 顶点是否匹配 self.visited = visited # 顶点是否被访问 self.M = [] # 匹配 self.res = 0 # 匹配数 # 遍历顶点A集合，得到最大匹配 def max_match(self): for i in self.set_A: if self.cx[i] == -1: # 未匹配 for key in self.set_B: # 将visited置0表示未访问过 self.visited[key] = 0 self.res += self.path(i) print('i', i, 'M',self.M) # 增广路置换获得更大的匹配 def path(self, u): for v in self.set_B: if self.edge[u][v] and (not self.visited[v]): # 如果可连且未被访问过 self.visited[v] = 1 # 访问该顶点 if self.cy[v] == -1: # 如果未匹配， 则建立匹配 self.cx[u], self.cy[v] = v, u self.M.append((u, v)) return 1 else: self.M.remove((self.cy[v], v)) # 如果匹配则删除之前的匹配 if self.path(self.cy[v]): # 递归调用 self.cx[u], self.cy[v] = v, u self.M.append((u, v)) return 1 print('v', v, 'M', self.M) return 0if __name__ == '__main__': set_A, set_B = ['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'] edge = &#123;'A': &#123;'E': 1, 'F': 0, 'G': 1, 'H': 0&#125;, 'B': &#123;'E': 0, 'F': 1, 'G': 0, 'H': 1&#125;, 'C': &#123;'E': 1, 'F': 0, 'G': 0, 'H': 1&#125;, 'D': &#123;'E': 0, 'F': 0, 'G': 1, 'H': 0&#125;&#125; # 1表示可以匹配，0表示不能匹配 cx, cy = &#123;'A': -1, 'B': -1, 'C': -1, 'D': -1&#125;, &#123;'E': -1, 'F': -1, 'G': -1, 'H': -1&#125; visited = &#123;'E': 0, 'F': 0, 'G': 0, 'H': 0&#125; dh = DFS_hungary(set_A, set_B, edge, cx, cy, visited) dh.max_match() print('res', dh.res) print('cx', cx) print('cy', cy) print('visited', visited)# 结果显示：# i A M [('A', 'E')] # 对于E点，可与A点连接，第一次匹配，直接在max_match打印，存在增广路：CEAG# v E M [('A', 'E')] # 对于E点，不能和B点连接，在path中打印# i B M [('A', 'E'), ('B', 'F')] # 对于F点，可与B点连接，直接在max_match打印，匹配数增加，存在增广路：CEAG# v E M [('B', 'F')] # 对于E点，可以与C连接，但已经与A点连接，从M中移除AE，在path中打印，进入递归内部# v F M [('B', 'F')]# i C M [('B', 'F'), ('A', 'G'), ('C', 'E')] # 对于G点，可与A点连接，直接在max_match打印，匹配数增加，存在增广路：DGAECH# v E M [('B', 'F'), ('A', 'G'), ('C', 'E')] # 对于E点，不能与D点连接，在path中打印# v F M [('B', 'F'), ('A', 'G'), ('C', 'E')] # 对于F点，不能与D点连接，在path中打印# v E M [('B', 'F')] # 对于G点，可以与D连接，但已经与A点连接，从M中移除AG，在path中打印，进入递归内部，继续移除CE# v F M [('B', 'F')]# v G M [('B', 'F')]# i D M [('B', 'F'), ('C', 'H'), ('A', 'E'), ('D', 'G')] # 无增广路# res 4# cx &#123;'A': 'E', 'B': 'F', 'C': 'H', 'D': 'G'&#125;# cy &#123;'E': 'A', 'F': 'B', 'G': 'D', 'H': 'C'&#125;# visited &#123;'E': 1, 'F': 0, 'G': 1, 'H': 1&#125; 动态规划16. 背包问题reference：https://zhuanlan.zhihu.com/p/93857890 0-1背包 不装入第i件物品，即dp[i−1][j]； 装入第i件物品（前提是能装下），即dp[i−1][j−w[i]] + v[i]。 即状态转移方程为 1dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) // j &gt;= w[i] 由上述状态转移方程可知，dp[i][j]的值只与dp[i-1][0,...,j-1]有关，所以我们可以采用动态规划常用的方法（滚动数组）对空间进行优化（即去掉dp的第一维）。需要注意的是，为了防止上一层循环的dp[0,...,j-1]被覆盖，循环的时候 j 只能逆向枚举（空间优化前没有这个限制），伪代码为： 12345// 01背包问题伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = W,...,w[i] // 必须逆向枚举!!! dp[j] = max(dp[j], dp[j−w[i]]+v[i]) 动态规划的核心思想避免重复计算在01背包问题中体现得淋漓尽致。第i件物品装入或者不装入而获得的最大价值完全可以由前面i-1件物品的最大价值决定，暴力枚举忽略了这个事实。 完全背包分析一 不装入第i种物品，即dp[i−1][j]，同01背包； 装入第i种物品，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到dp[i−1][j−w[i]]而应该转移到dp[i][j−w[i]]，即装入第i种商品后还可以再继续装入第种商品。 所以状态转移方程为 1dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) // j &gt;= w[i] 这个状态转移方程与01背包问题唯一不同就是max第二项不是dp[i-1]而是dp[i]。 和01背包问题类似，也可进行空间优化，优化后不同点在于这里的 j 只能正向枚举而01背包只能逆向枚举，因为这里的max第二项是dp[i]而01背包是dp[i-1]，即这里就是需要覆盖而01背包需要避免覆盖。所以伪代码如下： 12345// 完全背包问题思路一伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = w[i],...,W // 必须正向枚举!!! dp[j] = max(dp[j], dp[j−w[i]]+v[i]) 由上述伪代码看出，01背包和完全背包问题此解法的空间优化版解法唯一不同就是前者的 j 只能逆向枚举而后者的 j 只能正向枚举，这是由二者的状态转移方程决定的。此解法时间复杂度为O(NW), 空间复杂度为O(W)。 分析二除了分析一的思路外，完全背包还有一种常见的思路，但是复杂度高一些。我们从装入第 i 种物品多少件出发，01背包只有两种情况即取0件和取1件，而这里是取0件、1件、2件…直到超过限重（k &gt; j/w[i]），所以状态转移方程为： 12# k为装入第i种物品的件数, k &lt;= j/w[i]dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125; 同理也可以进行空间优化，需要注意的是，这里max里面是dp[i-1]，和01背包一样，所以 j 必须逆向枚举，优化后伪代码为 123456// 完全背包问题思路二伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = W,...,w[i] // 必须逆向枚举!!! for k = [0, 1,..., j/w[i]] dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i]) 相比于分析一，此种方法不是在O(1)时间求得dp[i][j]，所以总的时间复杂度就比分析一大些了，为 级别。 分析三、转换成01背包01背包问题是最基本的背包问题，我们可以考虑把完全背包问题转化为01背包问题来解：将一种物品转换成若干件只能装入0件或者1件的01背包中的物品。 最简单的想法是，考虑到第 i 种物品最多装入 W/w[i] 件，于是可以把第 i 种物品转化为 W/w[i] 件费用及价值均不变的物品，然后求解这个01背包问题。 更高效的转化方法是采用二进制的思想：把第 i 种物品拆成重量为 、价值为 的若干件物品，其中 k 取遍满足 的非负整数。这是因为不管最优策略选几件第 i 种物品，总可以表示成若干个刚才这些物品的和（例：13 = 1 + 4 + 8）。这样就将转换后的物品数目降成了对数级别。 多重背包分析一此时的分析和完全背包的分析二差不多，也是从装入第 i 种物品多少件出发：装入第i种物品0件、1件、…n[i]件（还要满足不超过限重）。所以状态方程为： 12# k为装入第i种物品的件数, k &lt;= min(n[i], j/w[i])dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125; 同理也可以进行空间优化，而且 j 也必须逆向枚举，优化后伪代码为 123456// 完全背包问题思路二伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = W,...,w[i] // 必须逆向枚举!!! for k = [0, 1,..., min(n[i], j/w[i])] dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i]) 总的时间复杂度约为 级别。 其他情形参考https://blog.csdn.net/weixin_41162823/article/details/87878853 1 恰好装满背包问题有时候还有一个限制就是必须恰好装满背包，此时基本思路没有区别，只是在初始化的时候有所不同。 如果没有恰好装满背包的限制，我们将dp全部初始化成0就可以了。因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。如果有恰好装满的限制，那只应该将dp[0,…,N][0]初始为0，其它dp值均初始化为-inf，因为此时只有容量为0的背包可以在什么也不装情况下被“恰好装满”，其它容量的背包初始均没有合法的解，应该被初始化为-inf。 2 求方案总数除了在给定每个物品的价值后求可得到的最大价值外，还有一类问题是问装满背包或将背包装至某一指定容量的方案总数。对于这类问题，需要将状态转移方程中的 max 改成 sum ，大体思路是不变的。例如若每件物品均是完全背包中的物品，转移方程即为 1dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]]) // j &gt;= w[i] 3 二维背包前面讨论的背包容量都是一个量：重量。二维背包问题是指每个背包有两个限制条件（比如重量和体积限制），选择物品必须要满足这两个条件。此类问题的解法和一维背包问题不同就是dp数组要多开一维，其他和一维背包完全一样，例如5.4节。 4 求最优方案一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由哪一个策略推出来的，这样便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。 以01背包为例，我们可以再用一个数组G[i][j]来记录方案，设 G[i][j] = 0表示计算 dp[i][j] 的值时是采用了max中的前一项(也即dp[i−1][j])，G[i][j] = 1 表示采用了方程的后一项。即分别表示了两种策略: 未装入第 i 个物品及装了第 i 个物品。其实我们也可以直接从求好的dp[i][j]反推方案：若 dp[i][j] = dp[i−1][j] 说明未选第i个物品，反之说明选了。 Leetcode相关练习题0 - 1 背包问题：416. 分割等和子集 题目给定一个只包含正整数的非空数组。问是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 由于所有元素的和sum已知，所以两个子集的和都应该是sum/2（所以前提是sum不能是奇数），即题目转换成从这个数组里面选取一些元素使这些元素和为sum/2。如果我们将所有元素的值看做是物品的重量，每件物品价值都为1，所以这就是一个恰好装满的01背包问题。 我们定义空间优化后的状态数组dp，由于是恰好装满，所以应该将dp[0]初始化为0而将其他全部初始化为INT_MIN，然后按照类似1.2节的伪代码更新dp： 123456int capacity = sum / 2;vector&lt;int&gt;dp(capacity + 1, INT_MIN);dp[0] = 0;for(int i = 1; i &lt;= n; i++) for(int j = capacity; j &gt;= nums[i-1]; j--) dp[j] = max(dp[j], 1 + dp[j - nums[i-1]]); 更新完毕后，如果dp[sum/2]大于0说明满足题意。 由于此题最后求的是能不能进行划分，所以dp的每个元素定义成bool型就可以了，然后将dp[0]初始为true其他初始化为false，而转移方程就应该是用或操作而不是max操作。完整代码如下： 1234567891011121314151617class Solution: def canPartition(self, nums: List[int]) -&gt; bool: n = len(nums) s = sum(nums) if s % 2: return False capacity = s // 2 dp = [False] * (capacity + 1) dp[0] = True for i in range(1, n+1): for j in range(capacity, nums[i-1]-1, -1): dp[j] = dp[j] or dp[j - nums[i-1]] return dp[capacity] 完全背包问题：322. 零钱兑换 题目给定一个价值amount和一些面值，假设每个面值的硬币数都是无限的，问我们最少能用几个硬币组成给定的价值。 如果我们将面值看作是物品，面值金额看成是物品的重量，每件物品的价值均为1，这样此题就是是一个恰好装满的完全背包问题了。不过这里不是求最多装入多少物品而是求最少，我们只需要将2.2节的转态转移方程中的max改成min即可，又由于是恰好装满，所以除了dp[0]，其他都应初始化为INT_MAX。完整代码如下： 123456789class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(len(coins)): for j in range(coins[i], amount+1): dp[j] = min(dp[j], 1 + dp[j - coins[i]]) return dp[amount] if dp[amount] != float('inf') else -1 17. 最长上升子序列1234567891011class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] for i in range(len(nums)): dp.append(1) for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 贪心加二分优化： 1234567891011class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] for i in range(len(nums)): dp.append(1) for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 18. 最长公共子序列123456789101112131415class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int: m = len(text1) n = len(text2) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1] 字符串26. KMP 字符串匹配练习题 https://leetcode.com/problems/implement-strstr/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Python program for KMP Algorithmdef KMPSearch(pat, txt): M = len(pat) N = len(txt) if M == 0: return 0 # create lps[] that will hold the longest prefix suffix # values for pattern lps = [0] * M j = 0 # index for pat[] # Preprocess the pattern (calculate lps[] array) computeLPSArray(pat, M, lps) i = 0 # index for txt[] while i &lt; N: if pat[j] == txt[i]: i += 1 j += 1 if j == M: # print("Found pattern at index " + str(i-j)) return i - j j = lps[j - 1] # mismatch after j matches elif i &lt; N and pat[j] != txt[i]: # Do not match lps[0..lps[j-1]] characters, # they will match anyway if j != 0: j = lps[j - 1] else: i += 1 return -1def computeLPSArray(pat, M, lps): len = 0 # length of the previous longest prefix suffix lps[0] # lps[0] is always 0 i = 1 # the loop calculates lps[i] for i = 1 to M-1 while i &lt; M: if pat[i] == pat[len]: len += 1 lps[i] = len i += 1 else: # This is tricky. Consider the example. # AAACAAAA and i = 7. The idea is similar # to search step. if len != 0: len = lps[len - 1] # Also, note that we do not increment i here else: lps[i] = 0 i += 1txt = "ABABDABACDABABCABAB"pat = "ABABCABAB"print(KMPSearch(pat, txt))# This code is contributed by Bhavya Jain 27. 字典树练习题：https://leetcode.com/problems/implement-trie-prefix-tree/ 1234567891011121314151617181920212223242526272829303132class TrieNode: # Initialize your data structure here. def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = Falseclass Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word): current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def startsWith(self, prefix): current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True 区间查询29. 线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Node: def __init__(self, start, end): self.start = start self.end = end self.total = 0 self.left = None self.right = Noneclass NumArray: def __init__(self, nums: List[int]): # helper function to create a segment tree def create_tree(left, right, nums): if left &gt; right: return None if left == right: node = Node(left, right) node.total = nums[left] return node mid = (left + right) // 2 node = Node(left, right) node.left = create_tree(left, mid, nums) node.right = create_tree(mid + 1, right, nums) node.total = node.left.total + node.right.total return node self.root = create_tree(0, len(nums) - 1, nums) def update(self, i: int, val: int) -&gt; None: def update_tree(root, i, val): if root.start == root.end and root.start == i: root.total = val return mid = (root.start + root.end) // 2 if i &lt;= mid: update_tree(root.left, i, val) else: update_tree(root.right, i, val) root.total = root.left.total + root.right.total update_tree(self.root, i, val) def sumRange(self, i: int, j: int) -&gt; int: def get_sum(root, i, j): if root.start == i and root.end == j: return root.total mid = (root.start + root.end) // 2 # in left tree if j &lt;= mid: return get_sum(root.left, i, j) elif mid &lt; i: return get_sum(root.right, i, j) else: l_s = get_sum(root.left, i, mid) r_s = get_sum(root.right, mid + 1, j) return l_s + r_s return get_sum(self.root, i, j) 30. 树状数组123456789101112131415161718class FenwickTree: def __init__(self, n): self.sums_ = [0] * (n + 1) def update(self, i, delta): while i &lt; len(self.sums_): self.sums_[i] += delta i += self.lowbit(i) def query(self, i): sum_ = 0 while i &gt; 0: sum_ += self.sums_[i] i -= self.lowbit(i) return sum_ def lowbit(self, x): return x &amp; (-x)]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客迁移]]></title>
    <url>%2F2021%2F02%2F05%2Fhexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[前言本人因做毕设需要购入新电脑一天，几乎所有开发工作都已迁移至新设备，独缺个人博客，趁寒假之际更新一下N久没有维护的个站。 在网上搜索的时候，看到有人利用git的branch，来实现多台设备同时能够维护博客，对我来说个人博客属于私人性质的东西，没有分布式更新的需求，因此本文所用方法只适合更换一台设备写博客，较为简单粗暴。 配置基础环境要配置基础环境，需要做以下几个步骤 安装git，并生成密钥，保存到github账号中 下载并安装Node.js（npm会自己跟着装好） 注意：nodejs 14 与 nodejs 12不完全兼容，本人是在nodejs 12 中建设网站的，转移到14时会有报错，具体解决方法见官方答疑 使用npm安装hexo ，具体指令为npm install -g hexo-cli 具体细节可以参照 建站过程整理这篇文章。 ❗️ 注意，安装完hexo之后不用hexo init 迁移相关文件需要迁移的文件只有： 博客配置文件./_config.yml 主题配置文件夹./theme/ 文章及相关内容的文件夹./source/ 模板文件夹./scaffolds/ 记录博客所有的插件的文件./package.json 在新电脑中重新部署在目录下博客主目录下运行以下命令，会自动读取./package.json的配置，完成相关环境的安装 1npm install 和之前相同，修改文章，生成静态文件，部署到github 12hexo ghexo d 部署时的问题当设备完全没有操作过git时，直接部署博客会报错： 此时是还没有将github主机的key添加到本地，可以临时从github中拉一个repo，过程中会提示添加github的key到本地： 参考资料： https://swayye.xyz/2020/01/10/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投稿经验总结]]></title>
    <url>%2F2019%2F12%2F16%2F%E6%8A%95%E7%A8%BF%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2020 www 投稿复盘：这篇文章经历非常坎坷，从2019年春节时开始准备，先是投了ijcai， 5月份出结果被拒，8月份修改了大实验，增加了验证性实验，投稿Ubicomp，以内容和普适计算领域无关被desk reject，最后修改一轮在10月份投了www。 在这个漫长的战线中，其实真正修改文章、补充实验的时间不到50%，大量的时间被耗费在等待导师意见的过程中。为了提高投稿的效率，可以有两种选择 1. 先斩后奏，看到合适的期刊先投着再说，至少能返回一些review意见。 2. 在等待过程开启新的课题，流水线作业，以量取胜。除此之外的经验教训是，导师不一定了解你做的工作，对你要投的track是否合适心里不一定有底，这次ubicomp desk reject 的理由就是与track无关， 有些主意一定得自己拿。 今年www首次设立rebuttal环节， 于12.12日收到review意见，相比于稿件数量爆炸性增长的某些顶会，www的reviewer 明显阅读稿件时更加认真，给出的意见也更加中肯，我也从review意见中收获良多，下面主要展示一些不足之处。 Review1 （strong reject）： 与DeepCrime 过于相似。 这是非常无奈的一点，学术文章也是手快有，手慢无。idea出来发现已经被人发表了，心情就和吃屎一样，只能在他的基础上增加补充实验。 所以，写文章尽量立意新，方法新，这样在效果上就有一定的转圜余地。 文章和track相关性不高。 实验结果的重要性阐述。 MAE 提升的0.1个百分点对现实有何意义？ 这个问题确实难回答，regression的预测指标不像分类问题那么直观。 Review2 (reject): 分段给出了评价。 拼写、语法、用词的错误，writing skill 还需再提升一下。 针对问题定义章节， 数据清洗方法未阐明，word2vec embedding 在少量天气条件下是否合理，输入输出不明确，对三类模型是否单独训练，每一层的数学表述没有必要，缺少模型参数的说明。 这里有的问题我在文章中是确实写明了，如输入输出，也给出了数学定义，对维度也做出了说明。如果review没有理解的话，推测依然还是写作的问题。 针对 evaluation部分， training / testing split 分割 需要对季节性差异做出解释（因为我只用了一年的时间，分为前3/4 和 后1/4）；错误率的提高是否适用于真实场景；赞扬对于网络不同结构的效用研究，补充了建议，增加对模型参数数量的考量，比如，引入attention可能并非是attention本身的作用，也有可能仅仅是参数的增加带来的效用？ 结论部分。建议增加一些讨论， 现实应用对预测的要求如何？未来的工作？evaluation的局限性？纽约可以代表其他城市么？如果犯罪分子提前知道了预测结果，而改变他们的行为，这种情况该如何处理？ Review3(reject): 缺少技术创新性，仅仅是结合了几种现存的方法。 技术细节缺少，如，demographic 特征的选择缺少理由；没有利用到poi上的check-in数据，poi上的语义信息；使用word2vec embed 天气情况的理由；SOTA方法用的不够多；baseline 里有用到 dynamic spatial pattern，但是paper里只用了static， 缺乏解释； 对中小型城市的效果如何？ community的具体定义，是Public Use Microdata Areas (PUMAs)么？ community对于实际应用来说依然太大？ 自我检讨部分：这篇文章其实先天上就不足，属于赶鸭子上架的作品，作为毕业设计的延伸，我当时在完成毕设后完全没有发文章的念头，划水了大半学期，随后在导师和师姐的鼓励下，于2019年春节前后匆忙投出一稿，果然白给。在写作过程中，因为看到了很多比较水的文章，导致自己心态有点膨胀，对顶会甚至生出一股轻视之意，从而忽略了对遣词造句的精益求精。更糟糕的是，我在整个研究目标设计上没有明确的框架规划，前期调查中也没有阅读足够的相关文章，没有明确问题的输出以及评价指标，没有考虑训练的细节，没有提前预判合理的特征分析，导致在后面的特征提取、实验设计、baseline选取时不得不根据实验结果临时修修补补，导致整篇文章逻辑相对混乱，脉络不甚清晰。总而言之，这篇文章虽然带给我极大的挫败感，甚至归宿也未知（我甚至都不想理它），但也让我实践了一个科研的完整流程，对接下来的研究工作应该也具备奠基意义吧。]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试经验总结]]></title>
    <url>%2F2019%2F12%2F11%2F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[时间: 2019.12.06 事件：微软冬季实习生面试两轮 状态：刚刷完Leetcode Top like 100， 还未针对面试准备过，抱着试试水的心态 结果：凉凉 第一轮： 英文自我介绍 项目经历简单介绍，问题：你从中遇到最大的挑战？ （最好能提前准备，言之有理即可） 白板编程。写程序检测是否是合法的ip地址，并将ip地址转换为一个int型整数。要求：检测非法字符，每个字符只读一遍。这些要求是在和面试官的沟通中一步步地明确的，所以不要一上来就闷头写代码，可以先给面试官讲一下思路。 结尾提问环节，尽量提前准备，最好可以问一些和业务有关的问题，展现你对申请岗位的热情。 第二轮： 英文自我介绍 网络基础知识 TCP, UDP 区别， 适用场景。五层网络协议模型。（没准备，答得很差） C++基础知识。 多态实现，运行时堆栈存储的数据，全局变量存放位置。（凭印象答，被面试官说答得不规范） 白板编程： 比较两个字符串版本大小，题目简单， 注意不要用字符串直接比较大小，先转换为int 工程题：设计一个数据结构，高效地检索ip地址。我只想到了把ip先转换为整数，用hash表存。但是空间效率太差，面试官最后公布答案，可以用平衡二叉树，最优解是字典树。（到这里其实面试时间有点超时了，我自己心态也有点崩，非常失败的收尾） 本次面试总结： 对面试的准备不够。 应对措施：买了一本《剑指offer》，全面了解一下面试的流程以及面试官的心理。 第一次经历这种形式的技术面，心态上hold不住。下个阶段多投中小厂锻炼一下。 ​]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可汗学院金融学笔记]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%8F%AF%E6%B1%97%E5%AD%A6%E9%99%A2%E9%87%91%E8%9E%8D%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[可汗学院的课程较为浅显，主要是结合生活中的具体例子对各种金融术语进行解析。因此，我个人更偏向于把这份笔记当作是术语字典。 利息前两集介绍了利息的概念，并举例对利息的计算方法做了说明。利息（interest）分为两种，单利（simple interest）和复利（compound interest）。复利是指在每经过一个计息期后，都要将所剩利息加入本金，以计算下期的利息，俗称利滚利，单利则不用计入。 计算方式如下，其中P为本金（principal）， t为时间， r为利率。 单利: P *(1 + tr) 复利: P*(1 + r)^t 现值现值（present value）就是根据当前收益率，算出一笔将来资金的当前价值。 例子：假定年收益率为5%， 现在有两种选择，1. 现在就给你100元。 2. 一年后给你110元。哪种选择更划算？ 同样有两种思考方式： 计算一年后收益（yield）= $100 * 1.05 = 105 &lt; 110​$, 选择方案2。 计算现值（PV）= $110 / (1 + 0.05) = 104.76 &gt; 100$， 选择方案2。此时5%就可以理解为贴现率（discount rate） 接下来用表格的方式给出3种选择, 初始值带$符号，假定无风险年利率依然为5%： Choice1 Choice2 Choice3 Today $100 $104.76 / 1.05 = 99.77$ $20 $+ 50 / 1.05 + 35 / 1.05^2 = 99.37$ Year1 $100 * 1.05 = 105$ $110 / 1.05 = 104.76$ $50 Year2 $105 * 1.05 = 110.25$ $110 $35 现在就能在三种选择间做一个比较了，以前人们在面临制定退休计划或是面对保险推销员时总会有所困惑，如在a年b年c年交纳多少钱，然后在b,c,d年回报多少钱，现在就可以用现值做比较。 在上例中，choice1 是最好的选择。 如果贴现率变成2%呢？ \begin{align*} PV_{choice1} &= 100 \\ PV_{choice2} &= 110 /1.02^2 = 105.72 \\ PV_{choice3} &= 20 + 50 /1.02 + 35/1.02^2 = 102.66 \end{align*}此时choice2 变成了最好的选择。 到目前为止，所有的讨论都是基于相同的贴现率，那么如果贴现率是随时间变化的呢？比如存1年和存5年的利率并不相同。 假设有一项国债，一年的年为利率1%，二年的年利率5%，此时三种方案又如何呢？ \begin{align*} PV_{choice1} &= 100 \\ PV_{choice2} &= 99.77 \\ PV_{choice3} &= 20 + 50/1.01 + 35 / 1.05^2 = 101.25 \end{align*}在以上三种情景中，支付流并没有改变，利率的改变最终影响了各种选择的现值。 而第三种选择就是所谓的贴现现金流，基于对各个时期利率的估计，利用Excel做一些简单的数学计算。 再次强调，上述计算是在无风险的假设下。在金融领域里，贴现率假设无处不在，这也是金融不同与科学的地方，实际上它没有正确的答案，这些模型只是帮助你理解事物的动态。 资产负债表也就是 Balance Sheet ，表里有如下的三种概念： 资产（Assets ），可以在将来带来经济利益的东西，如钱可以用来买东西、雇佣工人、度假等，再如房子可以居住； 负债（Liability ），对别人的经济负担或者义务，需要在将来偿还的； 权益（Equity ），所有的资产在偿清债务之后剩余的。 计算公式：A = L + E 假设你现在有$250k现金，房价为 $1000k, 对应着三种情况： A. 贷款买房前 B. 贷款后，银行说，你的信用等级不错，那就借给你吧；我就保留了一个IOU借据在银行。 C. 买房后， 此时有了法律保障的房契以及银行的借据。 情况 E L A A $250k 0 $250k B $250k $750k $1m C $房子 - $750k $750k 房子 通常银行不会轻易贷款给你，需要有超过贷款额20%左右的资产作为抵押，当然现买的房子也可以。如果还不上贷款，那么银行就会收回房子，这时银行会赚25万，而你自己什么都没有了。而如果在这个过程中房价变化了，比如升值或者贬值了，负债不会变化，而权益会随着房价的变化而变化。 债券和股票公司和个人一样，也有资产负债表。公司有两种途径来融资，1.发行股票。2.发行债券。这两者的区别是来源于资产负债表的不同部分。 股票（stock）本质上来源于公司的权益，假设有一个公司，它的财报显示总资产是$100m, 负债是$60m, 则对应的权益应为$40m。此时如果它在市场上发行了1000万股股票，理论上每股价格应为$4($Equity / the number of stocks$)。而如果此时市场上的价格为每股$3, 则市场认为这个公司的权益没有财报显示的那么高，当然市场的反应不一定对，也有可能是股价被低估。 公司的债务是在银行贷的款，银行可能将这些债务做成债券（bond）投放到市场上出售，如果银行发行了6w份该公司的债券，则相应的每份价格应为$1000。当债券到期，购买者能获得本金以及一定的利息。 股票划分的是权益，而债券划分的是公司债务。两者都是证券（security），也许原文在表达上更清晰一点：A security in the equity world is a stock，A security in the debt world is a bond. 对于股票持有者，他就是公司拥有人之一，获得的收益会随着公司盈利的变化而变化，而债券持有人相当于公司债权人，一定程度上不受公司经营的影响，换句话说，只要公司还的起钱，无论亏损还是盈利，该还多少钱还得还多少。 思考题：当公司破产清算时，是优先还钱给债券持有人，还是分红给股东？ 答案：破产清算，先是偿还企业员工的工资和所欠税款。然后偿还债权人，其次偿还次级债的。最后才轮到股权的清偿。]]></content>
      <categories>
        <category>经济</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市学习从入门到放弃]]></title>
    <url>%2F2018%2F12%2F28%2F%E8%82%A1%E5%B8%82%E5%9B%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[作为一颗韭菜，虽然摆脱不了被割的命运，但是希望能够多学一点东西，至少被割的明白一点。 新股民必备常识投资资金的准备一定是一段时间闲置不用的资金（最多占存款的25%），做好血本无归的打算。 投资方式的准备长期、中期、短期投资，取决于资金的闲置时间； 激进、稳健、保守，取决于投资者的水平、精力； 投资技巧的准备选股的技巧； 趋势的判断； 确定买卖的时机，回避风险的技巧； 技术指标，波浪理论； 注意：先学习再入市！！！ 交易规则交易时间： 周一至周五（法定休假日除外） 上午9：30——11：30 下午1：00——3：00 交易单位股，100股=1手， 委托买入数量必须为100股或其整数倍。 涨跌幅限制在一个交易日内，除首日上市证券外，每只证券的交易价格相对上一个交易日收市价的涨跌幅度不得超过10%，超过涨跌幅限价的委托为无效委托。 “T+1”交易“T”表示交易，“T+1”表示交易日第二天。 该制度指的是投资者当天买入的证券不能在当天卖出，需待第二天才可以卖出。 （A股为T+1交收，B股为T+3交收） 投资方法与技巧证券分析的主要方法1.基本面分析（侧重长期分析） 分析影响股票市场供求关系的要素： 宏观经济情况 行业动态变化（比如前两年锂电池、汽车，18年芯片） 上市公司的业绩前景、财务结构、经营状况（白酒行业里的贵州茅台） 政治因素，心理因素 资料来源：上市招股书、财务报告、上市报告等 2.技术分析 根据市场行情变化分析 两个主要指标：价格、成交量 3.资金面分析 中国股市从早期庄家过渡到了机构博弈的时代：包括银行基金、社保基金、企业年金、私募基金、保险基金等。 分析以上主要资金流的行为。 证券投资分析的主要步骤 信息资料的收集和整理 大势研判 个股选择 （中长线选行业、区域，如自贸区、概念、业绩、成长性和发展潜力，短期看技术面和资金面） 制定操作计划（人民币就像兵，不要当作赌博） 确定买卖时机 （主要依靠分析技术指标） 技术分析的基础知识 基本要素：量价时空 最大优点：贴近市场，获得收益周期短，见效快 主要方法：K线分析、切线分析、形态分析（w底m头）、技术指标（MACD） 适用范围：短期投资操作，长期投资预测一定要和基本面结合！ 技术分析是概率的，不可能百分百正确！ K线理论浅析K线起源K线起源于18世纪中叶日本德川幕府时代，从事粮食生意的商人用于记录米价涨跌的一种图表。K线图形似蜡烛，故也称蜡烛图。（Candle前面发K音） K线含义K线4个价位是一个四维向量，反应股价的高低和变化趋势。按时间周期不同可以分为：5分钟K线、30分钟K线、60分钟K线、日K线、周K线、月K线、年K线等。 按4个价位的关系，K线可以分成3类：阳线类、阴线类、非阳非阴类。 记录方法 收盘价&gt;开盘价 红色 开盘价&gt;收盘价 绿色 K线类型 阳线类 ​ a. 没有上下影线的阳线，表明开盘以后，买方势强，股价节节攀升，尾市收于当日最高价。如果涨幅很大，则称大阳线；涨幅小，则称小阳线。 b. 无上影线有下影线的阳K线，表明开盘后股价曾经在某一时刻跌破开盘价，创出全日最低。其后，由于买盘力量强大，股价向上突破开盘价，并以全天最高价收盘。 c. 无下影线有上影线的阳K线，开盘价即是全日最低价，然后股价上升到最高价，收盘时受挫回落构成上影线，但收盘价仍然在开盘价之上。此类K线表明股价在上升中遭受到阻力、但股价仍然在上升。 d. 有上下影线的阳线，实体与影线的关系，以开盘价和收盘价为平衡位。 阴线类 a. 没有上下影线的阴线，表明开市后，股价一路下跌，并以最低价收盘，开盘价即是最高价。 b. 无下影线有上影线的阴K线，属先涨后跌型，收盘价是全日最低价。也称光脚阳线，一般代表行情看淡。 c. 无上影线有下影线的阴K线（图有问题），表明股价先跌而后有所回升，构成下影线收盘。一般说明下档虽然出现了支撑，但行情一时还难以变好。 d. 有上下影线的阴线。 非阳非阴类 a. T字形K线，收盘价等于开盘价，也等于最高价。如果在高位，就是见顶信号。 b. 一字线，最高价、最低价、收盘价、开盘价均相等，全天只有一个成交价。上升期中表示强势，啪啪涨停板；下降期就是弱势（乐视网）。 c. 十字形K线，表明股价曾高于及低于开盘价，但收盘价与开盘价相同。高位见顶信号，低位见底信号。 d. 倒丁字形K线，收盘价等于开盘价，且等于最低价。开盘后涨幅较大，收盘时跌至最低，以开盘价收市。也称零位线。 注意：单独的图形是不能用来判断行情的，一定要结合趋势！！！ 移动平均线使用软件：通达信（随个人喜好） 什么是移动平均线移动平均线（MA，Moving Average）：是以道琼斯的“平均成本概念”为理论基础，采用统计学中“移动平均”原理，将一段时间内的股票价格平均值连成曲线，用来显示股价的历史波动情况，进而反映股价指数未来发展趋势的技术分析方法。 依照计算周期可以分为短期（5、10日），中期（30日）和长期（60、120日）。 MA5：5日平均线，白色。 MA10：10日平均线，黄色。 MA30：30日平均线，紫色。 MA60：60日平均线，绿色。 移动平均线运用法则移动平均线所表示的意义 事先声明：以下所有判断均有一定滞后性！！！ 上升行情初期，短期移动平均线从下向上突破中长期移动平均线，形成的交叉叫黄金交叉。预示股价将上涨。如图所示，5日均线上穿10日均线形成的交叉。10日突破30日也是黄金交叉。 当短期移动平均线向下跌破中长期移动平均线形成的交叉叫做死亡交叉。预示股价将下跌。如图所示，10日均线下穿30日均线。 在上升行情进入稳定期，5、10、30日移动平均线从上而下依次顺序排列，向右上方移动，成为多头排列。预示股价将大幅上涨。 在下跌行情中，5、10、30日移动平均线自下而上依次顺序排列，向右下方移动，成为空头排列，预示股价将大幅下跌。 在上升行情中，股价位于移动平均线之上，走多头排列的均线可视为多方的防线；当股价回档至移动平均线附近时，各条移动平均线依次产生支撑力量，买盘入场推动股价再度上升，这就是MA的助涨作用。 在下跌行情中，股价在移动平均线的下方，呈空头排列的均线可以视为空方的防线，当股价反弹到移动平均线附近时，便会遇到阻力，卖盘涌出，促使股价进一步下跌，这就是MA的助跌作用。 成交量怎么看有句老话：新手看价，高手看量，老手看势。 这里的量就是指成交量，也是分析庄家动向的重要依据。 成交量是K线图下方的副图。 柱状图颜色与K线一致，高度表示买卖的数量。 多头市场特征和空头市场特征多头就是看涨股票的人 多头市场特征： 股价上升，成交量增加 股价回档，成交量减少 股价盘整，成交量萎缩 股价再度上升，成交量随之增加 红色阶段股价上升，成交量上升； 紫色阶段股价盘整，成交量萎缩； 绿色阶段，股价回档，成交量减少。 空头是指看空后市，看跌的人 股价下跌，成交量减少 股价反弹，成交量增加 股价盘整，成交量减少 股价再度下跌，成交量下跌 可以看到人气越来越弱。 多空平衡——市场上看涨和看跌的人势力基本均衡 成交量小技巧温和放量一般出现在市场底部区域，并且在这之前已经出现了一波下跌或者行情调整。 巨量，是指股价在运行过程中突然放出巨大的成交量，一般当天放出的成交量至少是前一天的两倍以上。 天量见天价不一定正确！如图： 股价在下跌过程中出现巨量，一般标志着做空能量的最后一次释放，股价会出现反弹。 股价在上升期中出现巨量，一般意味着动能的耗尽，股价会出现回调或者滞涨。 地量，指成交量呈现极度缩小的状态，表明盘中交易相当的冷淡，成交很不积极。 这种情况一般出现在股价经过一波长期下跌的底部区域。 地量一般会出现阴跌不止的现象，或者证明主力把筹码锁的很死。 通过把股价锁定在底部，洗出不坚定的散户，为盈利做准备。 MACD指标MACD指标概念和原理趋向指标——平滑异同移动平均线（MACD，Moving Average Convergence Divergence），是Geral Appel于1979年提出的，它是一项利用短期（常用为12日）移动平均线和长期（常用为26日)移动平均线之间的聚合与分离状况，对买进、卖出时机做出研判的技术指标。有“指标之王”的美誉。 打开软件，最下面的副图就是MACD，双击可展开。 MACD图中也有金叉和死叉，这里的金叉是指白线从下往上上穿黄线，反之则是死叉。 MACD指标简单实战技巧 情况一：低位金叉 DIFF线（白）与DEA线（黄）金叉的位置，如果出现在零轴下方，并且远离零轴，这个金叉就称为低位金叉。投资者可将此时的金叉，仅仅视为股价的一次短期调整。 情况二：零轴附近金叉的买点 如果上涨趋势已经形成，DIFF线与DEA线的金叉发生在零轴附近，那么此时是投资者买入的绝佳时机。 情况三：高位金叉的买点 如果DIFF线与DEA线的金叉发生在零轴以上，且处于距离零轴较远的区域，那么该金叉就被称为高位金叉，高位金叉一般出现在股价上涨过程中的回调。高位金叉一般也是可以买入的。 情况一：低位死叉的卖点 低位死叉，是指发生在零轴下方较远地方的死叉。这种低位死叉，经常出现在下跌趋势中向上反弹结束时，因此低位死叉是反弹结束的卖出信号。此时，没有入场的投资者要注意持币观望，仍然持有股票被深度套牢的投资者，要注意风险。 情况二：零轴附近死叉的卖点 如果之前的市场方向一直都是下跌趋势，此时DIFF线在零轴附近跌破DEA线形成的交叉被称为零轴附近死叉，它表明市场在零轴附近已经积聚了较多的做空能量，死叉出现，预示着市场向下的动能开始释放，股价接下来将延续原来的下跌趋势。 分时走势图打开软件，选中一只股票，点开，默认是显示日线图，在上方菜单栏中选择分时按钮，即可调出分时图。 什么是走势图分时走势图也叫即时走势图，它是把股票市场的交易信息实时地用曲线在坐标图上加以显示的技术图形。坐标的横轴是开市的时间，纵轴的上半部分是股价或指数，下半部分显示的是成交量（黄色）。分时走势图是股市现场交易的即时资料。 分时走势图分为指数分时走势图和个股分时走势图。 分时走势图中的名词及含义上图就是上证指数的分时图，白色曲线表示上证交易所对外公布的大盘指数，也就是加权数。黄色曲线是不考虑上市股票发行数量的多少，将所有股票对上证指数的影响等同对待，是不含加权数的大盘指数。 参考白色曲线和黄色曲线的相对位置关系，可以得到以下信息： 当指数上涨，黄色曲线在白色曲线走势之上时，表示发行数量少（盘小）的股票涨幅较大；而当黄色曲线在白色曲线走势之下，则表示发行数量多（盘大）的股票涨幅较大。 当指数下跌时，如果黄色曲线仍然在白色曲线之上，这表示小盘股的跌幅小于大盘股的跌幅；如果白色曲线反居于黄色曲线之上，则说明小盘股的跌幅大于大盘股的跌幅。 红色、绿色的柱线反映当前大盘所有股票的买盘和卖盘的数量对比情况。红柱增长，表示买盘大于卖盘，指数将逐渐上涨；红柱缩短，表示卖盘大于买盘，指数将逐渐下跌。绿柱增长，指数下跌量增加；绿柱缩短，指数下跌量减小。黄色柱线表示每分钟的成交量，单位为手。 个股的分时走势图就不一样了。 白色曲线表示该种股票分时成交价格，黄色曲线表示该种股票的平均价格。下方柱线是每分钟的成交量。 分时图旁边有一些名词： 外盘指成交价是卖出价时，成交手数的总和；内盘指成交价是买入价时成交手数的总和。 当外盘&gt;&gt;内盘时，且股价也在上涨过程中，表明很多人在抢盘；当外盘&lt;&lt;内盘时，且股价在下跌，表明很多在抛售。（简单的方法就看颜色） 卖一 ~ 五是委托卖出的价格，买一 ~ 五委托买入的价格。旁边黄色的是是委托的手数。 委比：委买与委卖手数之差与之和的比例。 委差：委买手数与委卖手数的差值。 当委比是正值的时候，表示买方的力量强，上涨的概率大；反之，同理。（但这个指标容易作假） 量比：当日总成交手数与近期平均成交手数的比值。&gt;1表示这个时刻的成交手数放大了，&lt;1代表是萎缩的。 PE：市盈率。属于基本面。 股市切线法之趋势线这一节很玄学，大家看看就好。 股票市场价格随着时间的推移，在图表上会留下其运行轨迹，这一轨迹呈现一定的方向性，方向性反映了价格的波动情况。简单地说，趋势就是价格波动的方向，或者说是证券市场运动的方向。 上升趋势线上升趋势线是在股价持续上涨过程中，将每次的调整低点相连而成的趋势线。 下降趋势线股价在持续下跌过程中，将每次的反弹高点相连而形成的趋势线。 对趋势线突破翻转的应用技巧一般来说，趋势线对价格今后的变动起约束作用，使价格总保持在这条趋势线的上方（上升趋势线）或下方（下降趋势线）。实际上，就是起支撑和压力的作用。 趋势线被突破后，就说明价格下一步的走势将要向相反的方向运行，越重要越有效的趋势线被突破，其转势的信号越强烈。 筹码理论筹码是什么在股市中，筹码是投资者手中持有的一定数量的股票。 在软件右下方点击“筹”即可查看筹码分布。 股票的交易是买卖双方在某个价位，进行成交而实现。随着价格的上升或下降，会在不同的区域产生不同的成交量。在不同价位的分布量，就造成了不同价位的持仓成本。点击右下方的“笔”，这个流通盘是固定的，这里有9.56亿的流通盘，就有9.56亿的筹码。将不同价位的筹码按照不同价位横向排列起来，就形成了筹码分布，如上图。 分布图中有不同的颜色，具体的解释在图例中有标注。例如，红色的表示5周期前成本，对于日线来说，就是往前5日~1日；粉红色是10周期成本，就是往前10日~5日。 筹码分布图的作用 能有效判断行情的性质和趋势 如果K线处于筹码密集区的上方，表示行情较强，即时回调也是暂时的；如果K线在大量筹码下方，则意味着行情较弱，很多人被套牢了。 能有效识别主力建仓和出货的全过程 一般分为建仓、洗盘、拉升、出货几个阶段。下面几幅图再现了完整的过程，到最后，筹码分布在K线两侧，散户没有实力继续拉升，只能被套牢。 ​ 能有效的判断行情发展中重要的支撑位和阻力位 可以从上面的主力出货过程看到，当大部分筹码分布于K线以下时，一般可以持积极心态；而当大部分筹码分布于K线以上时，则要小心谨慎。 认识庄家庄家的分类一、按照运作周期来分：长线庄家、中线庄家、短线庄家 长线运作周期至少1年，上涨幅度至少一倍，控盘程度很高，能达到60%~80%，有明显坐庄痕迹，庄家实力雄厚，在宏观面、政策面、个股基本面都有一个很好的把握；中线周期一般在半年到一年，控制的筹码在50%左右，上涨幅度在40%以上，中线庄家往往借助中级行情，利用一些利好以及一些个股基本面的重大变化来拉高，或者通过板块联动；短线周期仅为几周或几个月，多见于强反弹的走势中，股价相对低的时候快速拉升，吸引中小散户。 二、按照庄家的主体性质来分： 政府庄家、券商庄家、上市公司庄家、基金庄家 政府庄家：在股市极度低迷的时候才会介入，主要为了维护国家金融秩序，防止经济崩溃。拥有雄厚的资金和配套的政策。 券商庄家：证券公司自己坐庄股票。信息融通，对金融政策反映灵敏，利用担当上市公司的推荐人，在第一时间了解上市公司的基本信息，市场上流通的被散户知晓的信息往往已经过时。注重成交量，可以多收手续费。必要的时候，明知亏本也会坐庄，主要是对成交的新股或者配股的股票进行护盘。 上市公司庄家: 自己炒自己的股票。对本公司的信息了如指掌。为了维护公司形象，会出手护盘，做亏本生意。 基金庄家：注重价值，注重绩优股。组合投资分散风险，力求保证资金的安全。与投资基金管理公司所属券商有千丝万缕的联系，在选股上有较强的契合性。 庄家的优势 资金的优势 高抛低吸，围点打援 消息方面的优势 信息渠道，包含获取的渠道和传播的渠道。尤其是上市公司的内幕信息。有时候会散播假消息，迷惑散户。 人才方面的优势 拥有一批高水平的操盘手、公关人才、行业分析师。 庄家与股评人之间的关系 股评人不知道自己被利用 庄家会关注一些著名股评人，适当配合股评人的预测。股评家最后落得个”股托“的名声。 股评人被庄家收买 送现金、送股票、送分红。吸货的时候，大唱悲观论调，动摇股民信心；吸住货时，又大肆吹捧，该股有成长性，有潜力。 庄家自己就是股评人 大机构会专门培养股评人。]]></content>
      <categories>
        <category>经济</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Draw multiple polylines on Google Map with Python]]></title>
    <url>%2F2018%2F10%2F12%2FDraw-multiple-polylines-on-Google-Map-with-Python%2F</url>
    <content type="text"><![CDATA[起因类似拥堵路段的绘制，我们需要在地图上根据风险程度，对不同的街道着以不同的颜色。 困难 关于绘制线段，Google Maps 只提供了 JavaScript API, 而我对JavaScript不熟。 数据文件在本地，需要进行预处理，JS并不擅长做数据处理和分析。 Google 提供的example只有相连的polyline(轨迹)， 而我需要的是绘制很多割裂的线段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Simple Polylines&lt;/title&gt; &lt;style&gt; /* Always set the map height explicitly to define the size of the div * element that contains the map. */ #map &#123; height: 100%; &#125; /* Optional: Makes the sample page fill the window. */ html, body &#123; height: 100%; margin: 0; padding: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="map"&gt;&lt;/div&gt; &lt;script&gt; // This example creates a 2-pixel-wide red polyline showing the path of // the first trans-Pacific flight between Oakland, CA, and Brisbane, // Australia which was made by Charles Kingsford Smith. function initMap() &#123; var map = new google.maps.Map(document.getElementById('map'), &#123; zoom: 3, center: &#123;lat: 0, lng: -180&#125;, mapTypeId: 'terrain' &#125;); var flightPlanCoordinates = [ &#123;lat: 37.772, lng: -122.214&#125;, &#123;lat: 21.291, lng: -157.821&#125;, &#123;lat: -18.142, lng: 178.431&#125;, &#123;lat: -27.467, lng: 153.027&#125; ]; var flightPath = new google.maps.Polyline(&#123; path: flightPlanCoordinates, geodesic: true, strokeColor: '#FF0000', strokeOpacity: 1.0, strokeWeight: 2 &#125;); flightPath.setMap(map); &#125; &lt;/script&gt; &lt;script async defer src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;callback=initMap"&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解决方案最终我选择用Python进行数据处理，将得到的处理结果以字符串形式插入到HTML文本中，保存，即可在浏览器中查看结果。 注意： string.format() 插入参数处需用“{}”标识，原有的“{}”需用“&#123;&#123;&#125;&#125;”代替。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def genHTML(filepath): polylines, pathcolors = getDataFromFile(filepath) return """ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Simple Polylines&lt;/title&gt; &lt;style&gt; /* Always set the map height explicitly to define the size of the div * element that contains the map. */ #map &#123;&#123; height: 100%; &#125;&#125; /* Optional: Makes the sample page fill the window. */ html, body &#123;&#123; height: 100%; margin: 0; padding: 0; &#125;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="map"&gt;&lt;/div&gt; &lt;script&gt; // This example creates a 2-pixel-wide red polyline showing the path of // the first trans-Pacific flight between Oakland, CA, and Brisbane, // Australia which was made by Charles Kingsford Smith. function initMap() &#123;&#123; var map = new google.maps.Map(document.getElementById('map'), &#123;&#123; zoom: 11, center: &#123;&#123;lat: 40.65, lng: -74.00&#125;&#125;, mapTypeId: 'roadmap' &#125;&#125;); var testpaths = [&#123;pathdata&#125;]; var testpathcolors = [&#123;pathcolors&#125;]; for (var i=0; i &lt;testpaths.length; i++)&#123;&#123; var polyline = new google.maps.Polyline(&#123;&#123; path: testpaths[i], geodesic: true, strokeColor: testpathcolors[i], strokeWeight: 2, strokeOpacity: 1 &#125;&#125;); polyline.setMap(map); &#125;&#125; &#125;&#125; &lt;/script&gt; &lt;script async defer src="https://maps.googleapis.com/maps/api/js?key=&#123;YOUR_API_KEY&#125;&amp;callback=initMap"&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; """.format(pathdata=polylines, pathcolors=pathcolors, YOUR_API_KEY="YourKey") ​ 生成后的HTML文件中的关键片段, 其中分离的线段可以通过多次调用setMap()实现： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt;function initMap() &#123; var map = new google.maps.Map(document.getElementById('map'), &#123; zoom: 11, center: &#123;lat: 40.65, lng: -74.00&#125;, mapTypeId: 'roadmap' &#125;); var testpaths = [ [&#123;lat: 40.64204491, lng: -73.98123241&#125;, &#123;lat: 40.64170758, lng: -73.98204322&#125;], [&#123;lat: 40.81448703, lng: -73.95545832&#125;, &#123;lat: 40.81365059, lng: -73.95349239&#125;], // More coordinates here... ] var testpathcolors = ['#EE00EE','#6495ED' //more color here... ] for (var i=0; i &lt;testpaths.length; i++)&#123; var polyline = new google.maps.Polyline(&#123; path: testpaths[i], geodesic: true, strokeColor: testpathcolors[i], strokeWeight: 2, strokeOpacity: 1 &#125;); polyline.setMap(map); &#125; &#125; &lt;/script&gt; 最终的结果：]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS前景思考]]></title>
    <url>%2F2018%2F08%2F12%2FCS%E5%89%8D%E6%99%AF%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[几年前选专业的时候，CS处于一个不温不火的状态，其实我本来最想去的是电气，不过最后阴差阳错地进了计算机相关的专业。社会上对程序员一直存在着一种偏见：木讷、不善交际、缺乏生活情趣、社会地位低、人脉资源少。身处这个行业的我虽然很不爽这种言论，但是就我亲身感受而言，这种偏见确实有其生长的土壤。我周围有很多优秀的技术大神，秉持着“技术至上”的理念，对技术的雕琢无可挑剔，但是不少人缺乏与人沟通的技巧，缺乏展示自我的手段和意愿，一心沉醉在技术世界，不闻窗外之事。加上近几年CS大热——留学申请难度逐年递增、海外CS从业人员回国抢食、转行潮、某些网络社区对CS的热捧，使得科班出身的从业人员内心骄纵之气日甚。 月满则亏，水满则溢。做人如此，行业也是如此。股市里有个非常著名的风向标：当菜市场大妈都知道要投资股市的时候，就是退场的最好时机。行业兴衰基本也符合这种规律，当大家一窝蜂地涌向某个行业时，这个行业离衰落也就不远了，至少相对于其本身不复辉煌，这是由市场的滞后性决定的。 这些年IT行业的发展也更加证实了这种判断。各种框架层出不穷，编程门槛和学习成本不断降低，开发效率越来越高，也正因为如此，产生了很多被科班人员嘲讽为“调包侠”的人，这应该是行业的进步，是生产力的进步，但对科班从业人员来说是其实是一种威胁，使得他们经年累月的知识积累无用武之地（有些夸张，但效用降低是真的），使得整体的待遇水平愈发趋近于社会平均水平。 也许有人会说，我不会变成调包侠，我要专注于计算机技术，把技术打磨到极致？很遗憾，这条路过于艰难。打磨到极致当然有用，但是有几人能够打磨到极致呢？技术的提升同样遵循经济学规律，越到后面，你需要投入时间、精力就越多，边际效益递减，边际成本剧增，况且高级技术职位的坑也就那么几个，你有多少信心认定那个坑一定是你的？另一方面，即使你跟上了技术发展的潮流也是不够的。以深度学习为例，这些岗位对知识的要求够高了吧？从2012大放异彩，到如今5年过去，从手撕神经网络，到caffe, tensorflow, 再到如今的keras, 深度学习也渐渐变成只要搭搭积木就能解决问题的技术。这样一来，懂得其他行业专业知识的人虽然代码写得不如科班人员迅速高效，但他们能解决计算机人员无法解决的问题（科班往往只关注计算机本身），由此创造的效益会超过科班高效节省的成本，整个社会会选择哪一种人不言自明。 和唯物史观认为的不同，计算机的历史更像是天才引领的历程，大多数普通人仅仅只是使用者，未来的计算机注定成为一种通用性的工具，CS专业也会变成一个普通的专业。作为科班人员，要正视这种危机，我们真正应该关注的是，如何利用计算机解决各行各业的问题，如何利用自己对计算机的深刻理解建立独一无二的个人价值。]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记忆体系与学习方法]]></title>
    <url>%2F2018%2F08%2F12%2F%E8%AE%B0%E5%BF%86%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高中及其之前的学习，老师都要求我们尽可能地掌握每一个知识点，这种学习方法的唯一目的就是为了在考试中取得高分。但是进入大学以后，知识量爆炸性地增长使得这种方法的学习效率变得很低，同时大学的学习不再纯粹地以分数为导向，更多地以解决实际问题为目标（为了找工作也算一种吧），在这种需求的推动下，势必要对原有的学习方法做出改进。 人脑的的历史可以追溯至万年以前，在这万年间，脑硬件的升级几乎微乎其微，而科技几百年的积累已经让它不堪重负，前沿研究员培养周期的延长便是最好的证明。这个问题很大程度上由人脑的存储结构造成的。人在思考的时候，能存储的条目至多不会超过七个，换句话说，人脑其实顶多只有七个寄存器而已；同时，已经存储在人脑中的知识如果不经常用，也会渐渐遗忘，就好比内存，掉电或者频繁地切换内容也会导致原有记忆的丢失；由此，人们发明了各种工具来辅助记忆，从石板、竹简、印刷、电子存储，再到互联网，人类获取外部知识的成本越来越低。 其实我们完全可以借鉴计算机存储体系设计的思路来优化我们的学习方法。因为我们最终的目标是解决问题，完成项目，所以重要的并不是你记住了哪些可以解决问题的手段（当然在具体的学习中过一遍脑子还是需要的），而是应该知道去哪里能找到解决问题的方法 。思维导图一类工具的出现大大简化了对知识建立索引的过程，索引的体量要远远小于对应的知识总量，减轻了大脑的记忆负担。剩下的工作就是要确定问题属于哪一类？该用哪一种手段解决？确定后到对应的索引中去找即可。那如果现有的记忆索引中没有呢？找资料-&gt;学习理解-&gt; 建立索引-&gt;添加至索引数据库，OK, Done。 上面的过程其实就是很多介绍学习方法的大牛所说的建立知识体系 ，结构化、体系化的知识确实更适应大脑的特点。]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习与电路理论]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[在Coursera上学习吴恩达的DeepLearning.ai时遇到了一个疑惑——为什么一定要深度学习？ 为什么要添加多个隐藏层？吴恩达给出了两种解释：1. 类比人脑， 越靠近输入的层学习越简单的特征，越靠近输出的层将前面各层的特征组合起来学习更加复杂的特征。2. 电路理论。 电路理论 There are functions you can compute with a “small” L-layer deep nerual network that shallower networks require exponentiall more hidden units to compute. 例如异或操作： 其中第一种解释很直观，第二种解释虽然直觉上是认可的，但应该有更通俗明白的解释。 假设输入三位数据$x_1x_2x_3$（e.g. 001), 采用深层网络可以拟合为$x_1⊕x_2⊕x_3$，而浅层网络拟合成什么样呢？这个时候就需要借助数电中根据真值表写逻辑表达式的技巧。 真值表如下 $x_1$ $x_2$ $x_3$ True Value 0 0 0 0 0 0 1 1 0 1 0 1 1 0 0 1 1 1 0 0 1 0 1 0 0 1 1 0 1 1 1 1 所以浅层网络推导为： $x_1⋅x_2⋅x_3+x_1′⋅x_2′⋅x_3+x_1′⋅x_2⋅x_3′+x_1⋅x_2′⋅x_3′$ 显然，深层网络需要的电子器件数为$O(logn)$, 而浅层网络需要$2^{n-1}$指数数量的器件，深层网络的拟合能力要远远强于浅层网络。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纽约犯罪风险预测结果可视化]]></title>
    <url>%2F2018%2F06%2F05%2F%E7%BA%BD%E7%BA%A6%E7%8A%AF%E7%BD%AA%E9%A3%8E%E9%99%A9%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[毕设炼丹已经很心累了，系里还强行要求论文也得弄个3~5min视频解说，手动尼克杨问号脸？？？反正现在视频怎么做还没思路，就先把纽约市的犯罪风险预测结果做个可视化吧。 技术路线数据科学领域……不用Python是不可能的，这辈子都不可能不用python的，Basemap嫌太丑，Echarts又不会，Plotly还要注册，就只能靠geoplotlib勉强混混日子这样子。 前期准备三个文件：2015年纽约犯罪风险等级预测结果risk4visualization.csv（毕设结果），纽约人口普查区域编号和实际社区编号的映射文件cd2puma.json（手动编写的）, 纽约社区边界文件Community_Districts.geojson（点此下载）。 绘制风险图设置颜色级别, 风险等级分为0~5级，共六个级别： 1cmap = ColorMap('Reds', alpha=255, levels=6) 获取颜色，这个函数在绘制每个区域时都会被调用，根据index来查找对应的风险等级，再转化为颜色。这里用的to_color()其实是用于连续值映射的，后来翻阅文档时发现了对应于离散值映射的函数create_set_cmap and colorbrewer，效果应该没差多少也就懒得改了。 123456789def get_color(properties): key = properties['boro_cd'] demogra_no = cd2puma.get(key) if demogra_no is None: return [0, 0, 0, 0] index = ((recorddate - datetime(2015, 1, 1)).days * 24 + hour) * 55 + pumalist.index(demogra_no) return cmap.to_color(riskLevel.ix[index, '0.0'], 5, 'lin') 绘制函数，考虑到区域内部用了红色，边界用暖色调会和谐一点，这里选用镉黄色，rgb(255, 153, 18)（颜色表参考）： 1234567def draw_riskmap(filename): geoplotlib.set_window_size(800, 600) geoplotlib.geojson('data/Community_Districts.geojson', fill=True, color=get_color) geoplotlib.geojson('data/Community_Districts.geojson', color=[255, 153, 18, 100]) geoplotlib.set_smoothing(True) geoplotlib.set_bbox(BoundingBox) geoplotlib.savefig('imgs/'+ filename) geoplotlib库还不支持添加图例和文字说明，这里迂回了一下，派生了一个TextLayer类，重写了draw()方法，使用ui_manager在图右上角添加时间信息。 123456class TextLayer(BaseLayer): def draw(self, proj, mouse_x, mouse_y, ui_manager): datestr = recorddate.strftime('%Y-%m-%d ') hourstr = str(hour) + ":00" ui_manager.info(datestr + hourstr) main()中绘制从2015年12月1日0点至2015年12月2日23点，共48h的风险图。 1234567dates = [datetime(2015, 12, 1), datetime(2015, 12, 2)]for recorddate in dates: for hour in range(24): filename = str((recorddate - dates[0]).days * 24 + hour) geoplotlib.add_layer(TextLayer()) draw_riskmap(filename) 制作动图将上述获得的48张图片导入PS中，在时间轴中添加帧动画制作GIF。结果如下： geoplotlib使用体验在CartoDB Positron提供的背景地图支持下，geoplotlib绘制的图显得精致了不少（当然不能和Echarts这种大杀器相提并论），不过文档和示例还有所欠缺，很多API仅仅靠reference没办法搞清楚用法，只能通过查看源码实现自行领会，或者查看github issue来拾点牙慧。 参考资料User Guide https://github.com/andrea-cuttone/geoplotlib/wiki/User-Guide Andrea Cuttone，Sune Lehmann，Jakob Eg Larsen Geoplotlib: a Python Toolbox for Visualizing Geographical Data https://arxiv.org/abs/1608.01933]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kindle 订阅RSS]]></title>
    <url>%2F2018%2F06%2F04%2FKindle-%E8%AE%A2%E9%98%85RSS%2F</url>
    <content type="text"><![CDATA[前几天去配运动眼镜竟然查出了散光，说穿了还是自己作的，明知道睡前躺着水手机伤眼睛，却还是乐此不疲。以前也强迫过自己不把手机带上床，然而收效甚微。那就换个思路吧，既然改变不了睡前看文章的习惯，那就改变文章的载体。相对来说，kindle墨水屏对视力友好了许多。 TIPS: 推荐自备梯子 Reabble 是 Kindle 上的 RSS 新闻阅读器，专为使用电子墨水屏的浏览器设计交互界面，媲美系统原生阅读体验。它使用一款非常优秀的 RSS 阅读器 Inoreader.com 来提供订阅管理。 要使用 Reabble，你首先需要有一个 Inoreader 帐号(点此注册)，并在里面添加一些订阅，需要指出的是，国内访问Inoreader不太稳定。 Reabble支持两种阅读方式, 在线阅读和离线阅读。 1. 在线阅读打开 Kindle 主屏右上角的菜单，选择「体验版网页浏览器」并打开网址 reabble.com，使用 Inoreader 帐号密码登录。 2. 离线阅读登录 Reabble.com ，打开 Reabble 左下角菜单，选择「推送设置」， 设置完成后，你会在每天指定的时间自动收到文章（接收文件时 Kindle 必须连网）。 Reabble 需要你指定哪些订阅源是自动推送的。在 Inoreader 中选中要推送的单一订阅源， 然后点击工具栏上的「订阅源设置」，再点击「指定到新文件夹」，然后输入「Kindle」。 系统会自动推送所有添加到 Kindle 文件夹中的订阅文章。 参考资料：http://reabble.com/help]]></content>
      <categories>
        <category>电子设备</category>
      </categories>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 1803更新导致l2tp失效]]></title>
    <url>%2F2018%2F06%2F03%2FWin10-1803%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4l2tp%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[Win10的强制自动更新一直是个比较头疼的问题，前半个月为了跑代码就把更新时间设在了五月底，本以为交完论文后就可以高枕无忧了，结果头儿的要求比较高，以学校要求托底的愿望破灭，无奈之下只能继续加内容呗，but…坑爹的事情来了，服务器连不上了！！！准确的说，我的服务器需要通过VPN连接，但是VPN拨号一直失败。因为我所有的工作都在服务器端完成，本地基本没有原始数据和代码，这样就抓瞎了TT。 Google了一圈后，发现大多数方法讲的都是重启，重设VPN, 或者修改注册表，前两个试过了没卵用，第三个本着不熟悉的条目不乱改的原则没有尝试，但从底下评论来看，效果也是堪忧。 按照我对微软尿性的理解，这八成又是新更新惹的祸，所以利用win10自带的版本回退功能退回了1709，重新尝试连接之后，果然没有NG。 【填坑时间 2018.10.12】 方法：修改了注册表，向其中添加了一项。 123HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\PolicyAgent &quot;AssumeUDPEncapsulationContextOnSendRule&quot;=dword:0x00000002 参数的解释：https://support.microsoft.com/en-us/help/926179/how-to-configure-an-l2tp-ipsec-server-behind-a-nat-t-device-in-windows 这里还有一个疑问：我挂的VPN连的是校内网的服务器，应该不涉及NAT转换，但修改操作是有效的，不知何解？]]></content>
      <categories>
        <category>故障排除</category>
      </categories>
      <tags>
        <tag>系统故障</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, Hexo]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用Hexo + Github搭建个人网站, 是非常简单的一件事。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——我说的 感谢 Z皓的博客，我是跟着链接中的博文搭建现在的网站的，这篇博文中不会展示其中具体的每一步，仅仅对其中用到的重要的命令做一个总结，想看详细过程的同学可以直接移步链接中的博文。 其实从大三开始我就萌生了建立个站的想法，一方面是为了装逼，另一方面也是为了在这个世界上留下点什么，但是因为课业、比赛等种种原因一直搁置，这一拖就拖到了毕业……写完毕业论文后终于有一小段空闲时间，就把这个已经尘封的计划重新捡起来吧。 第一步：安装Node.js和Git, 在Github中建立个站的repo第二步：安装Hexo, 推荐新建一个blog文件夹1$ npm install hexo -g 检查Hexo是否安装成功 1$ hexo -v 初始化该文件夹(成功的话可以看到 “Start blogging with Hexo”) 1$ hexo init 安装所需的组件 1$ npm install 第三步：体验Hexo首次体验 1$ hexo g 开启服务器，访问本地服务器 1$ hexo s 如果端口被占用了 1$ hexo server -p &lt;port&gt; 第四步：将Hexo与Github page连接起来这里省略了设置Git的user name 和 email, 以及ssh key的配置过程。 配置Deployment, 找到网站根目录下的_config.yml文件， 修改repo信息 第五步：撰写博客新建一篇博文 1$ hexo new post &lt;blog-name&gt; 在生成以及部署文章之前，需要安装一个扩展 1$ npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以生成及部署了 1$ hexo d -g 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 到此，基本的搭建过程已经全部结束了，如果想更改博客的样式主题请参考进阶教程。 图片插入问题解决方法使用Markdown语法插入图片时，首页的显示是正常的，但是点击文章链接查看单篇时，所有的图片均无法正常显示。观察url可知，在首页时，url为：https://hostname/, 而转到单篇文章时url变成了：https://hostname/year/month/date/post-name, Markdown语法显然是失效的。 注意：以下方法仅针对hexo3及以上版本 找到_config.yml配置文件post_asset_folder项，设置为true。 此时创建新博文后在source/_post文件夹下会出现一个post-name.md文件和/post-name文件夹，将博文需要的图片都存放于此。 在文章中需要插入图片的地方输入： 1&#123;% asset_img &lt;filename&gt; 图片的说明 %&#125; 文章加密安装加密模块: https://github.com/D0n9X1n/hexo-blog-encrypt 1$ npm install --save hexo-blog-encrypt 快速使用: 将password字段添加至文章头 1234title: Hello Worlddate: 2020-03-13 21:12:21password: muyiio---]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>website</tag>
      </tags>
  </entry>
</search>
