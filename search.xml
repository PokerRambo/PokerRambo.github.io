<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo美化之添加live2d动画]]></title>
    <url>%2F2021%2F02%2F05%2Fhexo%E7%BE%8E%E5%8C%96%E4%B9%8B%E6%B7%BB%E5%8A%A0live2d%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[1.hexo博客文件目录下安装live2D插件1bashnpm install --save hexo-helper-live2d 2.下载live2D动画模型动画选项及对应效果展示 live2d-widget-model-chitoselive2d-widget-model-z16live2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01live2d-widget-model-haru/02live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wanko 安装示例 1npm install live2d-widget-model-tororo 3. 修改配置文件_config.yml123456789101112131415161718192021# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true #隐藏/显示 pluginRootPath: live2dw/ #插件在站点上的根路径(相对) pluginJsPath: lib/ #与插件根目录相关的JavaScript路径(相对) pluginModelPath: assets/ #与插件根(相对)相关的模型路径 scriptFrom: local # Default # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # Your custom url tagMode: false #是否只替换live2d标签而不是注入到所有页面 log: false #是否在控制台显示日志 model: use: live2d-widget-model-wanko #安装的模型包名称 display: #设置位置和宽高（设置的宽高*2为实际像素，如：50=100px） position: right width: 200 height: 400 mobile: show: false #是否在移动端上显示 参考资料： https://www.guoxh.com/blog/2019/03/15/hexo%E9%9B%86%E6%88%90live2D%E5%8A%A8%E7%94%BB/]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网笔试常用数据结构与算法总结(python 模板)]]></title>
    <url>%2F2021%2F02%2F05%2F%E4%BA%92%E8%81%94%E7%BD%91%E7%AC%94%E8%AF%95%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-python-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[常用数据结构和算法模板（python）经典1.埃拉托斯特尼筛法1234567891011121314151617181920212223def countPrimes(n): ''' 输出 &lt;= n 的质数个数 :param n: 整数 :return: 质数个数 ''' if n &lt; 2: return 0 isPrime = [True] * (n + 1) isPrime[0] = isPrime[1] = False i = 2 while i * i &lt;= n: if isPrime[i]: for j in range(i*i, n+1, i): isPrime[j] = False i += 1 cnt = 0 for flag in isPrime: if flag: cnt += 1 return cnt 参考习题 https://leetcode-cn.com/problems/count-primes/, 答案如下，和模板略有区别： 123456789101112131415161718192021222324class Solution: def countPrimes(self, n: int) -&gt; int: ''' 返回小于 n 的质数个数 :param n: :return: ''' if n &lt;= 2: return 0 isPrime = [True] * (n) isPrime[0] = isPrime[1] = False i = 2 while i * i &lt; n: if isPrime[i]: for j in range(i*i, n, i): isPrime[j] = False i += 1 cnt = 0 for flag in isPrime: if flag: cnt += 1 return cnt 2. 快速幂1234567891011def myPow(x: float, n: int) -&gt; float: res = 1.0 base = x e = abs(n) while e: if e &amp; 1 == 1: res *= base base *= base e &gt;&gt;= 1 return res if n &gt;= 0 else 1.0 / res 练习题：https://leetcode-cn.com/problems/powx-n/ 12345678910111213141516class Solution: def myPow(self, x: float, n: int) -&gt; float: def quick_pow(x, n): base = x ans = 1 while n: if n &amp; 1: ans *= base base *= base n &gt;&gt;= 1 return ans return quick_pow(x, n) if n &gt; 0 else 1/quick_pow(x, abs(n)) 3. 大数模拟大数加法练习题：leetcode 415 https://leetcode-cn.com/problems/add-strings/ 123456789101112131415def addStrings(self, num1: str, num2: str) -&gt; str: ''' 大数加法 ''' res = "" i, j, carry = len(num1) - 1, len(num2) - 1, 0 while i &gt;= 0 or j &gt;= 0: # 高位补零 n1 = int(num1[i]) if i &gt;= 0 else 0 n2 = int(num2[j]) if j &gt;= 0 else 0 tmp = n1 + n2 + carry carry = tmp // 10 res = str(tmp % 10) + res i, j = i - 1, j - 1 return "1" + res if carry else res 大数乘法练习题：leetcode 43 https://leetcode.com/problems/multiply-strings/ 1234567891011121314151617181920def multiply(num1, num2): product = [0] * (len(num1) + len(num2)) # placeholder for multiplication ndigit by mdigit result in n+m digits position = len(product) - 1 # position within the placeholder for n1 in num1[::-1]: tempPos = position for n2 in num2[::-1]: product[tempPos] += int(n1) * int(n2) # ading the results of single multiplication product[tempPos - 1] += product[tempPos] // 10 # bring out carry number to the left array product[tempPos] %= 10 # remove the carry out from the current array tempPos -= 1 # first shifting the multplication to the end of the first integer position -= 1 # then once first integer is exhausted shifting the second integer and starting # once the second integer is exhausted we want to make sure we are not zero padding pointer = 0 # pointer moves through the digit array and locate where the zero padding finishes while pointer &lt; len(product) - 1 and product[ pointer] == 0: # if we have zero before the numbers shift the pointer to the right pointer += 1 return ''.join(map(str, product[pointer:])) # only report the digits to the right side of the pointer 计算进位： 计算 carry = tmp // 10，代表当前位相加是否产生进位；添加当前位： 计算 tmp = n1 + n2 + carry，并将当前位 tmp % 10 添加至 res 头部；索引溢出处理： 当指针 i或j 走过数字首部后，给 n1，n2 赋值为 00，相当于给 num1，num2 中长度较短的数字前面填 00，以便后续计算。当遍历完 num1，num2 后跳出循环，并根据 carry 值决定是否在头部添加进位 11，最终返回 res 即可。复杂度分析： 时间复杂度 O(max(M,N))O(max(M,N))：其中 MM，NN 为 22 数字长度，按位遍历一遍数字（以较长的数字为准）；空间复杂度 O(1)O(1)：指针与变量使用常数大小空间。 4. GCD12345678def gcd(a, b): ''' 这里不用判断a, b的相对大小,如果 a &lt; b, 在递归调用 gcd(b, a%b)时 自动调换了顺序。 ''' if b == 0: return a return gcd(b, a % b) 参考习题：https://leetcode-cn.com/problems/simplified-fractions/，最简分数，gcd的应用 12345678910111213class Solution: def simplifiedFractions(self, n: int) -&gt; List[str]: def gcd(a, b): if b == 0: return a return gcd(b, a % b) res = [] for i in range(2, n+1): for j in range(1, i): if gcd(j, i) == 1: res.append(str(j) + '/' + str(i)) return res 5. LCM (最小公倍数)12def lcm(a, b): return a * b // gcd(a, b) 7. 二分搜索万能模板 12345678910111213141516171819202122# 当分支逻辑不能排除右边界，选左中位数，如果选右中位数则会出现死循环def binary_search1(left, right): while left &lt; right: mid = (left + right) &gt;&gt; 1 if check(mid): left = mid + 1 else: right = mid # 退出循环的时候， 视情况，是否需要单独判断left是否满足条件 return leftdef binary_search2(left, right): while left &lt; right: # 选择右中位数 while left &lt; right: mid = (left + right + 1) &gt;&gt; 1 if check(mid): right = mid - 1 else: left = mid # 退出循环的时候， 视情况，是否需要单独判断left是否满足条件 return left 8. 并查集12345678910111213parent = list(range(N))def find(x): if x != parent[x]: # 路径完全压缩 parent[x] = find(parent[x]) return parent[x]def union(x, y): root1 = find(x) root2 = find(y) parent[root2] = root1 类形式： 123456789101112131415161718class DSU: def __init__(self, N): self.parent = list(range(N+1)) self.edges = 0 def find(self, x): if x != self.parent[x]: # 路径完全压缩 self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): root1 = self.find(x) root2 = self.find(y) self.parent[root2] = root1 self.edges += 1 图论9. 最小生成树(贪心思想)解析 花花酱：https://www.youtube.com/watch?v=wmW8G8SrXDs 图论500 题 https://blog.csdn.net/luomingjun12315/article/details/47438607 Kruskal算法 主体部分如下，需要用到并查集（下面完整测试案例中会给出） 1234567891011121314def kruskal(): ''' 适用于求稀疏图 :return: 最小生成树的边和 ''' cost = 0 for u, v, w in sorted(edges, key=lambda x: x[2]): pu, pv = find(u), find(v) if pu == pv: continue # 等同于union parent[pu] = pv cost += w return cost leetcode中缺少相关的习题，固用花花酱视频中的例子测试了一下： 123456789101112131415161718192021222324252627282930313233n = 4edges = [[0, 1, 1], [0, 3, 3], [0, 2, 6], [2, 3, 2], [1, 2, 4]]parent = list(range(n))def find(x): if x != parent[x]: # 路径完全压缩 parent[x] = find(parent[x]) return parent[x]def union(x, y): root1 = find(x) root2 = find(y) parent[root2] = root1def kruskal(): ''' 适用于求稀疏图 :return: 最小生成树的边和 ''' cost = 0 for u, v, w in sorted(edges, key=lambda x: x[2]): pu, pv = find(u), find(v) if pu == pv: continue # 等同于union parent[pu] = pv cost += w return cost Prim算法 12345678910111213141516171819202122def prime(): ''' 适用于稠密图，堆优化版本 :return: cost ''' q = [] cost = 0 seen = set() # push a dummy node, (cost, node) heappush(q, (0, 0)) for _ in range(n): w, u = heappop(q) if u in seen: continue cost += w seen.add(u) for v, w in graph[u]: if v in seen: continue heappush(q, (w, v)) return cost 测试代码： 123456789101112131415161718192021222324252627282930313233343536from collections import defaultdictfrom heapq import *n = 4 # 顶点数edges = [[0, 1, 1], [0, 3, 3], [0, 2, 6], [2, 3, 2], [1, 2, 4]]graph = defaultdict(list)for e in edges: graph[e[0]].append((e[1], e[2])) graph[e[1]].append((e[0], e[2]))def prime(): ''' 适用于稠密图，堆优化版本 :return: cost ''' q = [] cost = 0 seen = set() # push a dummy node, (cost, node) heappush(q, (0, 0)) for _ in range(n): w, u = heappop(q) if u in seen: continue cost += w seen.add(u) for v, w in graph[u]: if v in seen: continue heappush(q, (w, v)) return costprint(prime())# 6 最短路算法合集统一习题：LC743 https://leetcode-cn.com/problems/network-delay-time/ 最短路算法的分类： 单源最短路 所有边权都是正数 朴素的Dijkstra算法 O(n^2) 适合稠密图 堆优化版的Dijkstra算法 O(mlog n)（m是图中节点的个数）适合稀疏图 存在负权边 Bellman-Ford O(nm) spfa 一般O(m), 最坏O(nm) 多源汇最短路 Floyd算法 O(n^3) 参考代码：https://leetcode.com/problems/network-delay-time/discuss/283711/python-bellman-ford-spfa-dijkstra-floyd-clean-and-easy-to-understand 11. 迪杰斯特拉算法单源最短路 所有边权都是正数 朴素的Dijkstra算法 O(n^2) 适合稠密图 堆优化版的Dijkstra算法 O(mlog n)（m是图中节点的个数）适合稀疏图 123456789101112131415161718192021222324def dijkstra(graph, source, N): ''' 单源最短路径算法 :param graph: 邻接矩阵，或者用字典实现 :param source: 起始点 :param N: 节点个数 :return: ''' # 如果是node 是 1-indexed dist = [float('inf')] * (N + 1) prev = [-1] * (N + 1) dist[source] = dist[0] = 0 hq = [(0, source)] while hq: d, u = heapq.heappop(hq) for v in graph[u]: alt = dist[u] + graph[u][v] if alt &lt; dist[v]: dist[v] = alt prev[v] = u heapq.heappush(hq, (alt, v)) return dist, prev 习题解答： 123456789101112131415161718192021222324252627282930313233343536class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: # construct graph graph = collections.defaultdict(dict) for u, v, time in times: graph[u][v] = time def dijkstra(graph, source, N): ''' 单源最短路径算法 :param graph: 邻接矩阵，或者用字典实现 :param source: 起始点 :return: ''' dist = [float('inf')] * (N + 1) prev = [-1] * (N + 1) # 如果是node 是 1-indexed dist[source] = dist[0] = 0 hq = [(0, source)] while hq: d, u = heapq.heappop(hq) for v in graph[u]: alt = dist[u] + graph[u][v] if alt &lt; dist[v]: dist[v] = alt prev[v] = u heapq.heappush(hq, (alt, v)) return dist, prev dist, _ = dijkstra(graph, K, N) # print(dist) ans = max(dist) return ans if ans != float('inf') else -1 Bellman-Ford 算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Python3 program for Bellman-Ford's single source# shortest path algorithm.# Class to represent a graphclass Graph: def __init__(self, vertices): self.V = vertices # No. of vertices self.graph = [] # function to add an edge to graph def addEdge(self, u, v, w): self.graph.append([u, v, w]) # utility function used to print the solution def printArr(self, dist): print("Vertex Distance from Source") for i in range(self.V): print("&#123;0&#125;\t\t&#123;1&#125;".format(i, dist[i])) # The main function that finds shortest distances from src to # all other vertices using Bellman-Ford algorithm. The function # also detects negative weight cycle def BellmanFord(self, src): # Step 1: Initialize distances from src to all other vertices # as INFINITE dist = [float("Inf")] * self.V dist[src] = 0 # Step 2: Relax all edges |V| - 1 times. A simple shortest # path from src to any other vertex can have at-most |V| - 1 # edges for _ in range(self.V - 1): # Update dist value and parent index of the adjacent vertices of # the picked vertex. Consider only those vertices which are still in # queue for u, v, w in self.graph: if dist[u] != float("Inf") and dist[u] + w &lt; dist[v]: dist[v] = dist[u] + w # Step 3: check for negative-weight cycles. The above step # guarantees shortest distances if graph doesn't contain # negative weight cycle. If we get a shorter path, then there # is a cycle. for u, v, w in self.graph: if dist[u] != float("Inf") and dist[u] + w &lt; dist[v]: print("Graph contains negative weight cycle") return # print all distance self.printArr(dist)g = Graph(5)g.addEdge(0, 1, -1)g.addEdge(0, 2, 4)g.addEdge(1, 2, 3)g.addEdge(1, 3, 2)g.addEdge(1, 4, 2)g.addEdge(3, 2, 5)g.addEdge(3, 1, 1)g.addEdge(4, 3, -3)# Print the solutiong.BellmanFord(0)# Initially, Contributed by Neelam Yadav# Later On, Edited by Himanshu Garg 123456789class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: dist = [float("inf") for _ in range(N)] dist[K-1] = 0 for _ in range(N-1): for u, v, w in times: if dist[u-1] + w &lt; dist[v-1]: dist[v-1] = dist[u-1] + w return max(dist) if max(dist) &lt; float("inf") else -1 12. spfa判断有无负环：如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图，但是可以判断是否出现负权环） 1234567891011121314151617class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: dist = [float("inf") for _ in range(N)] K -= 1 dist[K] = 0 weight = collections.defaultdict(dict) for u, v, w in times: weight[u-1][v-1] = w queue = collections.deque([K]) while queue: u = queue.popleft() for v in weight[u]: if dist[u] + weight[u][v] &lt; dist[v]: dist[v] = dist[u] + weight[u][v] queue.append(v) return max(dist) if max(dist) &lt; float("inf") else -1 13. Floyd-Warshall12345678910def floyd_warshall(graph, N): ''' :param graph: 邻接矩阵 :param N: 节点数 :return: 修改过的邻接矩阵 ''' for k in range(N): for i in range(N): for j in range(N): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) 习题答案： 12345678910111213141516171819202122class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: # construct graph dist = [[float("inf") for _ in range(N)] for _ in range(N)] for u, v, w in times: dist[u - 1][v - 1] = w for i in range(N): dist[i][i] = 0 def floyd_warshall(graph, N): ''' :param graph: 邻接矩阵 :param N: 节点数 :return: 修改过的邻接矩阵 ''' for k in range(N): for i in range(N): for j in range(N): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) floyd_warshall(dist, N) return max(dist[K - 1]) if max(dist[K - 1]) &lt; float("inf") else -1 二分图14. 染色法123456789101112131415161718192021222324252627282930import collectionsdef isBipartite(graph): n = len(graph) UNCOLORED, RED, GREEN = 0, 1, 2 color = [UNCOLORED] * n # graph 不一定是连通图 for i in range(n): if color[i] == UNCOLORED: q = collections.deque([i]) color[i] = RED while q: node = q.popleft() cNei = (GREEN if color[node] == RED else RED) for neighbor in graph[node]: if color[neighbor] == UNCOLORED: q.append(neighbor) color[neighbor] = cNei elif color[neighbor] != cNei: return False, None return True, colorgraph = [[1,3], [0,2], [1,3], [0,2]]print(isBipartite(graph))'''(True, [1, 2, 1, 2])''' 15. 匈牙利算法 (用于寻找最大匹配)讲解：https://www.renfei.org/blog/bipartite-matching.html https://blog.csdn.net/dark_scope/article/details/8880547 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class DFS_hungary(): # https://www.icode9.com/content-1-615590.html # 参数初始化 def __init__(self, set_A, set_B, edge, cx, cy, visited): self.set_A, self.set_B = set_A, set_B # 顶点集合 self.edge = edge # 顶点是否连边 self.cx, self.cy = cx, cy # 顶点是否匹配 self.visited = visited # 顶点是否被访问 self.M = [] # 匹配 self.res = 0 # 匹配数 # 遍历顶点A集合，得到最大匹配 def max_match(self): for i in self.set_A: if self.cx[i] == -1: # 未匹配 for key in self.set_B: # 将visited置0表示未访问过 self.visited[key] = 0 self.res += self.path(i) print('i', i, 'M',self.M) # 增广路置换获得更大的匹配 def path(self, u): for v in self.set_B: if self.edge[u][v] and (not self.visited[v]): # 如果可连且未被访问过 self.visited[v] = 1 # 访问该顶点 if self.cy[v] == -1: # 如果未匹配， 则建立匹配 self.cx[u], self.cy[v] = v, u self.M.append((u, v)) return 1 else: self.M.remove((self.cy[v], v)) # 如果匹配则删除之前的匹配 if self.path(self.cy[v]): # 递归调用 self.cx[u], self.cy[v] = v, u self.M.append((u, v)) return 1 print('v', v, 'M', self.M) return 0if __name__ == '__main__': set_A, set_B = ['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'] edge = &#123;'A': &#123;'E': 1, 'F': 0, 'G': 1, 'H': 0&#125;, 'B': &#123;'E': 0, 'F': 1, 'G': 0, 'H': 1&#125;, 'C': &#123;'E': 1, 'F': 0, 'G': 0, 'H': 1&#125;, 'D': &#123;'E': 0, 'F': 0, 'G': 1, 'H': 0&#125;&#125; # 1表示可以匹配，0表示不能匹配 cx, cy = &#123;'A': -1, 'B': -1, 'C': -1, 'D': -1&#125;, &#123;'E': -1, 'F': -1, 'G': -1, 'H': -1&#125; visited = &#123;'E': 0, 'F': 0, 'G': 0, 'H': 0&#125; dh = DFS_hungary(set_A, set_B, edge, cx, cy, visited) dh.max_match() print('res', dh.res) print('cx', cx) print('cy', cy) print('visited', visited)# 结果显示：# i A M [('A', 'E')] # 对于E点，可与A点连接，第一次匹配，直接在max_match打印，存在增广路：CEAG# v E M [('A', 'E')] # 对于E点，不能和B点连接，在path中打印# i B M [('A', 'E'), ('B', 'F')] # 对于F点，可与B点连接，直接在max_match打印，匹配数增加，存在增广路：CEAG# v E M [('B', 'F')] # 对于E点，可以与C连接，但已经与A点连接，从M中移除AE，在path中打印，进入递归内部# v F M [('B', 'F')]# i C M [('B', 'F'), ('A', 'G'), ('C', 'E')] # 对于G点，可与A点连接，直接在max_match打印，匹配数增加，存在增广路：DGAECH# v E M [('B', 'F'), ('A', 'G'), ('C', 'E')] # 对于E点，不能与D点连接，在path中打印# v F M [('B', 'F'), ('A', 'G'), ('C', 'E')] # 对于F点，不能与D点连接，在path中打印# v E M [('B', 'F')] # 对于G点，可以与D连接，但已经与A点连接，从M中移除AG，在path中打印，进入递归内部，继续移除CE# v F M [('B', 'F')]# v G M [('B', 'F')]# i D M [('B', 'F'), ('C', 'H'), ('A', 'E'), ('D', 'G')] # 无增广路# res 4# cx &#123;'A': 'E', 'B': 'F', 'C': 'H', 'D': 'G'&#125;# cy &#123;'E': 'A', 'F': 'B', 'G': 'D', 'H': 'C'&#125;# visited &#123;'E': 1, 'F': 0, 'G': 1, 'H': 1&#125; 动态规划16. 背包问题reference：https://zhuanlan.zhihu.com/p/93857890 0-1背包 不装入第i件物品，即dp[i−1][j]； 装入第i件物品（前提是能装下），即dp[i−1][j−w[i]] + v[i]。 即状态转移方程为 1dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) // j &gt;= w[i] 由上述状态转移方程可知，dp[i][j]的值只与dp[i-1][0,...,j-1]有关，所以我们可以采用动态规划常用的方法（滚动数组）对空间进行优化（即去掉dp的第一维）。需要注意的是，为了防止上一层循环的dp[0,...,j-1]被覆盖，循环的时候 j 只能逆向枚举（空间优化前没有这个限制），伪代码为： 12345// 01背包问题伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = W,...,w[i] // 必须逆向枚举!!! dp[j] = max(dp[j], dp[j−w[i]]+v[i]) 动态规划的核心思想避免重复计算在01背包问题中体现得淋漓尽致。第i件物品装入或者不装入而获得的最大价值完全可以由前面i-1件物品的最大价值决定，暴力枚举忽略了这个事实。 完全背包分析一 不装入第i种物品，即dp[i−1][j]，同01背包； 装入第i种物品，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到dp[i−1][j−w[i]]而应该转移到dp[i][j−w[i]]，即装入第i种商品后还可以再继续装入第种商品。 所以状态转移方程为 1dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) // j &gt;= w[i] 这个状态转移方程与01背包问题唯一不同就是max第二项不是dp[i-1]而是dp[i]。 和01背包问题类似，也可进行空间优化，优化后不同点在于这里的 j 只能正向枚举而01背包只能逆向枚举，因为这里的max第二项是dp[i]而01背包是dp[i-1]，即这里就是需要覆盖而01背包需要避免覆盖。所以伪代码如下： 12345// 完全背包问题思路一伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = w[i],...,W // 必须正向枚举!!! dp[j] = max(dp[j], dp[j−w[i]]+v[i]) 由上述伪代码看出，01背包和完全背包问题此解法的空间优化版解法唯一不同就是前者的 j 只能逆向枚举而后者的 j 只能正向枚举，这是由二者的状态转移方程决定的。此解法时间复杂度为O(NW), 空间复杂度为O(W)。 分析二除了分析一的思路外，完全背包还有一种常见的思路，但是复杂度高一些。我们从装入第 i 种物品多少件出发，01背包只有两种情况即取0件和取1件，而这里是取0件、1件、2件…直到超过限重（k &gt; j/w[i]），所以状态转移方程为： 12# k为装入第i种物品的件数, k &lt;= j/w[i]dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125; 同理也可以进行空间优化，需要注意的是，这里max里面是dp[i-1]，和01背包一样，所以 j 必须逆向枚举，优化后伪代码为 123456// 完全背包问题思路二伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = W,...,w[i] // 必须逆向枚举!!! for k = [0, 1,..., j/w[i]] dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i]) 相比于分析一，此种方法不是在O(1)时间求得dp[i][j]，所以总的时间复杂度就比分析一大些了，为 级别。 分析三、转换成01背包01背包问题是最基本的背包问题，我们可以考虑把完全背包问题转化为01背包问题来解：将一种物品转换成若干件只能装入0件或者1件的01背包中的物品。 最简单的想法是，考虑到第 i 种物品最多装入 W/w[i] 件，于是可以把第 i 种物品转化为 W/w[i] 件费用及价值均不变的物品，然后求解这个01背包问题。 更高效的转化方法是采用二进制的思想：把第 i 种物品拆成重量为 、价值为 的若干件物品，其中 k 取遍满足 的非负整数。这是因为不管最优策略选几件第 i 种物品，总可以表示成若干个刚才这些物品的和（例：13 = 1 + 4 + 8）。这样就将转换后的物品数目降成了对数级别。 多重背包分析一此时的分析和完全背包的分析二差不多，也是从装入第 i 种物品多少件出发：装入第i种物品0件、1件、…n[i]件（还要满足不超过限重）。所以状态方程为： 12# k为装入第i种物品的件数, k &lt;= min(n[i], j/w[i])dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125; 同理也可以进行空间优化，而且 j 也必须逆向枚举，优化后伪代码为 123456// 完全背包问题思路二伪代码(空间优化版)dp[0,...,W] = 0for i = 1,...,N for j = W,...,w[i] // 必须逆向枚举!!! for k = [0, 1,..., min(n[i], j/w[i])] dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i]) 总的时间复杂度约为 级别。 其他情形参考https://blog.csdn.net/weixin_41162823/article/details/87878853 1 恰好装满背包问题有时候还有一个限制就是必须恰好装满背包，此时基本思路没有区别，只是在初始化的时候有所不同。 如果没有恰好装满背包的限制，我们将dp全部初始化成0就可以了。因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。如果有恰好装满的限制，那只应该将dp[0,…,N][0]初始为0，其它dp值均初始化为-inf，因为此时只有容量为0的背包可以在什么也不装情况下被“恰好装满”，其它容量的背包初始均没有合法的解，应该被初始化为-inf。 2 求方案总数除了在给定每个物品的价值后求可得到的最大价值外，还有一类问题是问装满背包或将背包装至某一指定容量的方案总数。对于这类问题，需要将状态转移方程中的 max 改成 sum ，大体思路是不变的。例如若每件物品均是完全背包中的物品，转移方程即为 1dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]]) // j &gt;= w[i] 3 二维背包前面讨论的背包容量都是一个量：重量。二维背包问题是指每个背包有两个限制条件（比如重量和体积限制），选择物品必须要满足这两个条件。此类问题的解法和一维背包问题不同就是dp数组要多开一维，其他和一维背包完全一样，例如5.4节。 4 求最优方案一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由哪一个策略推出来的，这样便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。 以01背包为例，我们可以再用一个数组G[i][j]来记录方案，设 G[i][j] = 0表示计算 dp[i][j] 的值时是采用了max中的前一项(也即dp[i−1][j])，G[i][j] = 1 表示采用了方程的后一项。即分别表示了两种策略: 未装入第 i 个物品及装了第 i 个物品。其实我们也可以直接从求好的dp[i][j]反推方案：若 dp[i][j] = dp[i−1][j] 说明未选第i个物品，反之说明选了。 Leetcode相关练习题0 - 1 背包问题：416. 分割等和子集 题目给定一个只包含正整数的非空数组。问是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 由于所有元素的和sum已知，所以两个子集的和都应该是sum/2（所以前提是sum不能是奇数），即题目转换成从这个数组里面选取一些元素使这些元素和为sum/2。如果我们将所有元素的值看做是物品的重量，每件物品价值都为1，所以这就是一个恰好装满的01背包问题。 我们定义空间优化后的状态数组dp，由于是恰好装满，所以应该将dp[0]初始化为0而将其他全部初始化为INT_MIN，然后按照类似1.2节的伪代码更新dp： 123456int capacity = sum / 2;vector&lt;int&gt;dp(capacity + 1, INT_MIN);dp[0] = 0;for(int i = 1; i &lt;= n; i++) for(int j = capacity; j &gt;= nums[i-1]; j--) dp[j] = max(dp[j], 1 + dp[j - nums[i-1]]); 更新完毕后，如果dp[sum/2]大于0说明满足题意。 由于此题最后求的是能不能进行划分，所以dp的每个元素定义成bool型就可以了，然后将dp[0]初始为true其他初始化为false，而转移方程就应该是用或操作而不是max操作。完整代码如下： 1234567891011121314151617class Solution: def canPartition(self, nums: List[int]) -&gt; bool: n = len(nums) s = sum(nums) if s % 2: return False capacity = s // 2 dp = [False] * (capacity + 1) dp[0] = True for i in range(1, n+1): for j in range(capacity, nums[i-1]-1, -1): dp[j] = dp[j] or dp[j - nums[i-1]] return dp[capacity] 完全背包问题：322. 零钱兑换 题目给定一个价值amount和一些面值，假设每个面值的硬币数都是无限的，问我们最少能用几个硬币组成给定的价值。 如果我们将面值看作是物品，面值金额看成是物品的重量，每件物品的价值均为1，这样此题就是是一个恰好装满的完全背包问题了。不过这里不是求最多装入多少物品而是求最少，我们只需要将2.2节的转态转移方程中的max改成min即可，又由于是恰好装满，所以除了dp[0]，其他都应初始化为INT_MAX。完整代码如下： 123456789class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(len(coins)): for j in range(coins[i], amount+1): dp[j] = min(dp[j], 1 + dp[j - coins[i]]) return dp[amount] if dp[amount] != float('inf') else -1 17. 最长上升子序列1234567891011class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] for i in range(len(nums)): dp.append(1) for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 贪心加二分优化： 1234567891011class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] for i in range(len(nums)): dp.append(1) for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 18. 最长公共子序列123456789101112131415class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int: m = len(text1) n = len(text2) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1] 字符串26. KMP 字符串匹配练习题 https://leetcode.com/problems/implement-strstr/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Python program for KMP Algorithmdef KMPSearch(pat, txt): M = len(pat) N = len(txt) if M == 0: return 0 # create lps[] that will hold the longest prefix suffix # values for pattern lps = [0] * M j = 0 # index for pat[] # Preprocess the pattern (calculate lps[] array) computeLPSArray(pat, M, lps) i = 0 # index for txt[] while i &lt; N: if pat[j] == txt[i]: i += 1 j += 1 if j == M: # print("Found pattern at index " + str(i-j)) return i - j j = lps[j - 1] # mismatch after j matches elif i &lt; N and pat[j] != txt[i]: # Do not match lps[0..lps[j-1]] characters, # they will match anyway if j != 0: j = lps[j - 1] else: i += 1 return -1def computeLPSArray(pat, M, lps): len = 0 # length of the previous longest prefix suffix lps[0] # lps[0] is always 0 i = 1 # the loop calculates lps[i] for i = 1 to M-1 while i &lt; M: if pat[i] == pat[len]: len += 1 lps[i] = len i += 1 else: # This is tricky. Consider the example. # AAACAAAA and i = 7. The idea is similar # to search step. if len != 0: len = lps[len - 1] # Also, note that we do not increment i here else: lps[i] = 0 i += 1txt = "ABABDABACDABABCABAB"pat = "ABABCABAB"print(KMPSearch(pat, txt))# This code is contributed by Bhavya Jain 27. 字典树练习题：https://leetcode.com/problems/implement-trie-prefix-tree/ 1234567891011121314151617181920212223242526272829303132class TrieNode: # Initialize your data structure here. def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = Falseclass Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word): current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def startsWith(self, prefix): current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True 区间查询29. 线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Node: def __init__(self, start, end): self.start = start self.end = end self.total = 0 self.left = None self.right = Noneclass NumArray: def __init__(self, nums: List[int]): # helper function to create a segment tree def create_tree(left, right, nums): if left &gt; right: return None if left == right: node = Node(left, right) node.total = nums[left] return node mid = (left + right) // 2 node = Node(left, right) node.left = create_tree(left, mid, nums) node.right = create_tree(mid + 1, right, nums) node.total = node.left.total + node.right.total return node self.root = create_tree(0, len(nums) - 1, nums) def update(self, i: int, val: int) -&gt; None: def update_tree(root, i, val): if root.start == root.end and root.start == i: root.total = val return mid = (root.start + root.end) // 2 if i &lt;= mid: update_tree(root.left, i, val) else: update_tree(root.right, i, val) root.total = root.left.total + root.right.total update_tree(self.root, i, val) def sumRange(self, i: int, j: int) -&gt; int: def get_sum(root, i, j): if root.start == i and root.end == j: return root.total mid = (root.start + root.end) // 2 # in left tree if j &lt;= mid: return get_sum(root.left, i, j) elif mid &lt; i: return get_sum(root.right, i, j) else: l_s = get_sum(root.left, i, mid) r_s = get_sum(root.right, mid + 1, j) return l_s + r_s return get_sum(self.root, i, j) 30. 树状数组123456789101112131415161718class FenwickTree: def __init__(self, n): self.sums_ = [0] * (n + 1) def update(self, i, delta): while i &lt; len(self.sums_): self.sums_[i] += delta i += self.lowbit(i) def query(self, i): sum_ = 0 while i &gt; 0: sum_ += self.sums_[i] i -= self.lowbit(i) return sum_ def lowbit(self, x): return x &amp; (-x)]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客迁移]]></title>
    <url>%2F2021%2F02%2F05%2Fhexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[前言本人因做毕设需要购入新电脑一天，几乎所有开发工作都已迁移至新设备，独缺个人博客，趁寒假之际更新一下N久没有维护的个站。 在网上搜索的时候，看到有人利用git的branch，来实现多台设备同时能够维护博客，对我来说个人博客属于私人性质的东西，没有分布式更新的需求，因此本文所用方法只适合更换一台设备写博客，较为简单粗暴。 配置基础环境要配置基础环境，需要做以下几个步骤 安装git，并生成密钥，保存到github账号中 下载并安装Node.js（npm会自己跟着装好） 注意：nodejs 14 与 nodejs 12不完全兼容，本人是在nodejs 12 中建设网站的，转移到14时会有报错，具体解决方法见官方答疑 使用npm安装hexo ，具体指令为npm install -g hexo-cli 具体细节可以参照 建站过程整理这篇文章。 ❗️ 注意，安装完hexo之后不用hexo init 迁移相关文件需要迁移的文件只有： 博客配置文件./_config.yml 主题配置文件夹./theme/ 文章及相关内容的文件夹./source/ 模板文件夹./scaffolds/ 记录博客所有的插件的文件./package.json 在新电脑中重新部署在目录下博客主目录下运行以下命令，会自动读取./package.json的配置，完成相关环境的安装 1npm install 和之前相同，修改文章，生成静态文件，部署到github 12hexo ghexo d 部署时的问题当设备完全没有操作过git时，直接部署博客会报错： 此时是还没有将github主机的key添加到本地，可以临时从github中拉一个repo，过程中会提示添加github的key到本地： 参考资料： https://swayye.xyz/2020/01/10/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[投稿经验总结]]></title>
    <url>%2F2019%2F12%2F16%2F%E6%8A%95%E7%A8%BF%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2020 www 投稿复盘：这篇文章经历非常坎坷，从2019年春节时开始准备，先是投了ijcai， 5月份出结果被拒，8月份修改了大实验，增加了验证性实验，投稿Ubicomp，以内容和普适计算领域无关被desk reject，最后修改一轮在10月份投了www。 在这个漫长的战线中，其实真正修改文章、补充实验的时间不到50%，大量的时间被耗费在等待导师意见的过程中。为了提高投稿的效率，可以有两种选择 1. 先斩后奏，看到合适的期刊先投着再说，至少能返回一些review意见。 2. 在等待过程开启新的课题，流水线作业，以量取胜。除此之外的经验教训是，导师不一定了解你做的工作，对你要投的track是否合适心里不一定有底，这次ubicomp desk reject 的理由就是与track无关， 有些主意一定得自己拿。 今年www首次设立rebuttal环节， 于12.12日收到review意见，相比于稿件数量爆炸性增长的某些顶会，www的reviewer 明显阅读稿件时更加认真，给出的意见也更加中肯，我也从review意见中收获良多，下面主要展示一些不足之处。 Review1 （strong reject）： 与DeepCrime 过于相似。 这是非常无奈的一点，学术文章也是手快有，手慢无。idea出来发现已经被人发表了，心情就和吃屎一样，只能在他的基础上增加补充实验。 所以，写文章尽量立意新，方法新，这样在效果上就有一定的转圜余地。 文章和track相关性不高。 实验结果的重要性阐述。 MAE 提升的0.1个百分点对现实有何意义？ 这个问题确实难回答，regression的预测指标不像分类问题那么直观。 Review2 (reject): 分段给出了评价。 拼写、语法、用词的错误，writing skill 还需再提升一下。 针对问题定义章节， 数据清洗方法未阐明，word2vec embedding 在少量天气条件下是否合理，输入输出不明确，对三类模型是否单独训练，每一层的数学表述没有必要，缺少模型参数的说明。 这里有的问题我在文章中是确实写明了，如输入输出，也给出了数学定义，对维度也做出了说明。如果review没有理解的话，推测依然还是写作的问题。 针对 evaluation部分， training / testing split 分割 需要对季节性差异做出解释（因为我只用了一年的时间，分为前3/4 和 后1/4）；错误率的提高是否适用于真实场景；赞扬对于网络不同结构的效用研究，补充了建议，增加对模型参数数量的考量，比如，引入attention可能并非是attention本身的作用，也有可能仅仅是参数的增加带来的效用？ 结论部分。建议增加一些讨论， 现实应用对预测的要求如何？未来的工作？evaluation的局限性？纽约可以代表其他城市么？如果犯罪分子提前知道了预测结果，而改变他们的行为，这种情况该如何处理？ Review3(reject): 缺少技术创新性，仅仅是结合了几种现存的方法。 技术细节缺少，如，demographic 特征的选择缺少理由；没有利用到poi上的check-in数据，poi上的语义信息；使用word2vec embed 天气情况的理由；SOTA方法用的不够多；baseline 里有用到 dynamic spatial pattern，但是paper里只用了static， 缺乏解释； 对中小型城市的效果如何？ community的具体定义，是Public Use Microdata Areas (PUMAs)么？ community对于实际应用来说依然太大？ 自我检讨部分：这篇文章其实先天上就不足，属于赶鸭子上架的作品，作为毕业设计的延伸，我当时在完成毕设后完全没有发文章的念头，划水了大半学期，随后在导师和师姐的鼓励下，于2019年春节前后匆忙投出一稿，果然白给。在写作过程中，因为看到了很多比较水的文章，导致自己心态有点膨胀，对顶会甚至生出一股轻视之意，从而忽略了对遣词造句的精益求精。更糟糕的是，我在整个研究目标设计上没有明确的框架规划，前期调查中也没有阅读足够的相关文章，没有明确问题的输出以及评价指标，没有考虑训练的细节，没有提前预判合理的特征分析，导致在后面的特征提取、实验设计、baseline选取时不得不根据实验结果临时修修补补，导致整篇文章逻辑相对混乱，脉络不甚清晰。总而言之，这篇文章虽然带给我极大的挫败感，甚至归宿也未知（我甚至都不想理它），但也让我实践了一个科研的完整流程，对接下来的研究工作应该也具备奠基意义吧。]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试经验总结]]></title>
    <url>%2F2019%2F12%2F11%2F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[时间: 2019.12.06 事件：微软冬季实习生面试两轮 状态：刚刷完Leetcode Top like 100， 还未针对面试准备过，抱着试试水的心态 结果：凉凉 第一轮： 英文自我介绍 项目经历简单介绍，问题：你从中遇到最大的挑战？ （最好能提前准备，言之有理即可） 白板编程。写程序检测是否是合法的ip地址，并将ip地址转换为一个int型整数。要求：检测非法字符，每个字符只读一遍。这些要求是在和面试官的沟通中一步步地明确的，所以不要一上来就闷头写代码，可以先给面试官讲一下思路。 结尾提问环节，尽量提前准备，最好可以问一些和业务有关的问题，展现你对申请岗位的热情。 第二轮： 英文自我介绍 网络基础知识 TCP, UDP 区别， 适用场景。五层网络协议模型。（没准备，答得很差） C++基础知识。 多态实现，运行时堆栈存储的数据，全局变量存放位置。（凭印象答，被面试官说答得不规范） 白板编程： 比较两个字符串版本大小，题目简单， 注意不要用字符串直接比较大小，先转换为int 工程题：设计一个数据结构，高效地检索ip地址。我只想到了把ip先转换为整数，用hash表存。但是空间效率太差，面试官最后公布答案，可以用平衡二叉树，最优解是字典树。（到这里其实面试时间有点超时了，我自己心态也有点崩，非常失败的收尾） 本次面试总结： 对面试的准备不够。 应对措施：买了一本《剑指offer》，全面了解一下面试的流程以及面试官的心理。 第一次经历这种形式的技术面，心态上hold不住。下个阶段多投中小厂锻炼一下。 ​]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可汗学院金融学笔记]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%8F%AF%E6%B1%97%E5%AD%A6%E9%99%A2%E9%87%91%E8%9E%8D%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[可汗学院的课程较为浅显，主要是结合生活中的具体例子对各种金融术语进行解析。因此，我个人更偏向于把这份笔记当作是术语字典。 利息前两集介绍了利息的概念，并举例对利息的计算方法做了说明。利息（interest）分为两种，单利（simple interest）和复利（compound interest）。复利是指在每经过一个计息期后，都要将所剩利息加入本金，以计算下期的利息，俗称利滚利，单利则不用计入。 计算方式如下，其中P为本金（principal）， t为时间， r为利率。 单利: P *(1 + tr) 复利: P*(1 + r)^t 现值现值（present value）就是根据当前收益率，算出一笔将来资金的当前价值。 例子：假定年收益率为5%， 现在有两种选择，1. 现在就给你100元。 2. 一年后给你110元。哪种选择更划算？ 同样有两种思考方式： 计算一年后收益（yield）= $100 * 1.05 = 105 &lt; 110​$, 选择方案2。 计算现值（PV）= $110 / (1 + 0.05) = 104.76 &gt; 100$， 选择方案2。此时5%就可以理解为贴现率（discount rate） 接下来用表格的方式给出3种选择, 初始值带$符号，假定无风险年利率依然为5%： Choice1 Choice2 Choice3 Today $100 $104.76 / 1.05 = 99.77$ $20 $+ 50 / 1.05 + 35 / 1.05^2 = 99.37$ Year1 $100 * 1.05 = 105$ $110 / 1.05 = 104.76$ $50 Year2 $105 * 1.05 = 110.25$ $110 $35 现在就能在三种选择间做一个比较了，以前人们在面临制定退休计划或是面对保险推销员时总会有所困惑，如在a年b年c年交纳多少钱，然后在b,c,d年回报多少钱，现在就可以用现值做比较。 在上例中，choice1 是最好的选择。 如果贴现率变成2%呢？ \begin{align*} PV_{choice1} &= 100 \\ PV_{choice2} &= 110 /1.02^2 = 105.72 \\ PV_{choice3} &= 20 + 50 /1.02 + 35/1.02^2 = 102.66 \end{align*}此时choice2 变成了最好的选择。 到目前为止，所有的讨论都是基于相同的贴现率，那么如果贴现率是随时间变化的呢？比如存1年和存5年的利率并不相同。 假设有一项国债，一年的年为利率1%，二年的年利率5%，此时三种方案又如何呢？ \begin{align*} PV_{choice1} &= 100 \\ PV_{choice2} &= 99.77 \\ PV_{choice3} &= 20 + 50/1.01 + 35 / 1.05^2 = 101.25 \end{align*}在以上三种情景中，支付流并没有改变，利率的改变最终影响了各种选择的现值。 而第三种选择就是所谓的贴现现金流，基于对各个时期利率的估计，利用Excel做一些简单的数学计算。 再次强调，上述计算是在无风险的假设下。在金融领域里，贴现率假设无处不在，这也是金融不同与科学的地方，实际上它没有正确的答案，这些模型只是帮助你理解事物的动态。 资产负债表也就是 Balance Sheet ，表里有如下的三种概念： 资产（Assets ），可以在将来带来经济利益的东西，如钱可以用来买东西、雇佣工人、度假等，再如房子可以居住； 负债（Liability ），对别人的经济负担或者义务，需要在将来偿还的； 权益（Equity ），所有的资产在偿清债务之后剩余的。 计算公式：A = L + E 假设你现在有$250k现金，房价为 $1000k, 对应着三种情况： A. 贷款买房前 B. 贷款后，银行说，你的信用等级不错，那就借给你吧；我就保留了一个IOU借据在银行。 C. 买房后， 此时有了法律保障的房契以及银行的借据。 情况 E L A A $250k 0 $250k B $250k $750k $1m C $房子 - $750k $750k 房子 通常银行不会轻易贷款给你，需要有超过贷款额20%左右的资产作为抵押，当然现买的房子也可以。如果还不上贷款，那么银行就会收回房子，这时银行会赚25万，而你自己什么都没有了。而如果在这个过程中房价变化了，比如升值或者贬值了，负债不会变化，而权益会随着房价的变化而变化。 债券和股票公司和个人一样，也有资产负债表。公司有两种途径来融资，1.发行股票。2.发行债券。这两者的区别是来源于资产负债表的不同部分。 股票（stock）本质上来源于公司的权益，假设有一个公司，它的财报显示总资产是$100m, 负债是$60m, 则对应的权益应为$40m。此时如果它在市场上发行了1000万股股票，理论上每股价格应为$4($Equity / the number of stocks$)。而如果此时市场上的价格为每股$3, 则市场认为这个公司的权益没有财报显示的那么高，当然市场的反应不一定对，也有可能是股价被低估。 公司的债务是在银行贷的款，银行可能将这些债务做成债券（bond）投放到市场上出售，如果银行发行了6w份该公司的债券，则相应的每份价格应为$1000。当债券到期，购买者能获得本金以及一定的利息。 股票划分的是权益，而债券划分的是公司债务。两者都是证券（security），也许原文在表达上更清晰一点：A security in the equity world is a stock，A security in the debt world is a bond. 对于股票持有者，他就是公司拥有人之一，获得的收益会随着公司盈利的变化而变化，而债券持有人相当于公司债权人，一定程度上不受公司经营的影响，换句话说，只要公司还的起钱，无论亏损还是盈利，该还多少钱还得还多少。 思考题：当公司破产清算时，是优先还钱给债券持有人，还是分红给股东？ 答案：破产清算，先是偿还企业员工的工资和所欠税款。然后偿还债权人，其次偿还次级债的。最后才轮到股权的清偿。]]></content>
      <categories>
        <category>经济</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[股市学习从入门到放弃]]></title>
    <url>%2F2018%2F12%2F28%2F%E8%82%A1%E5%B8%82%E5%9B%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[作为一颗韭菜，虽然摆脱不了被割的命运，但是希望能够多学一点东西，至少被割的明白一点。 新股民必备常识投资资金的准备一定是一段时间闲置不用的资金（最多占存款的25%），做好血本无归的打算。 投资方式的准备长期、中期、短期投资，取决于资金的闲置时间； 激进、稳健、保守，取决于投资者的水平、精力； 投资技巧的准备选股的技巧； 趋势的判断； 确定买卖的时机，回避风险的技巧； 技术指标，波浪理论； 注意：先学习再入市！！！ 交易规则交易时间： 周一至周五（法定休假日除外） 上午9：30——11：30 下午1：00——3：00 交易单位股，100股=1手， 委托买入数量必须为100股或其整数倍。 涨跌幅限制在一个交易日内，除首日上市证券外，每只证券的交易价格相对上一个交易日收市价的涨跌幅度不得超过10%，超过涨跌幅限价的委托为无效委托。 “T+1”交易“T”表示交易，“T+1”表示交易日第二天。 该制度指的是投资者当天买入的证券不能在当天卖出，需待第二天才可以卖出。 （A股为T+1交收，B股为T+3交收） 投资方法与技巧证券分析的主要方法1.基本面分析（侧重长期分析） 分析影响股票市场供求关系的要素： 宏观经济情况 行业动态变化（比如前两年锂电池、汽车，18年芯片） 上市公司的业绩前景、财务结构、经营状况（白酒行业里的贵州茅台） 政治因素，心理因素 资料来源：上市招股书、财务报告、上市报告等 2.技术分析 根据市场行情变化分析 两个主要指标：价格、成交量 3.资金面分析 中国股市从早期庄家过渡到了机构博弈的时代：包括银行基金、社保基金、企业年金、私募基金、保险基金等。 分析以上主要资金流的行为。 证券投资分析的主要步骤 信息资料的收集和整理 大势研判 个股选择 （中长线选行业、区域，如自贸区、概念、业绩、成长性和发展潜力，短期看技术面和资金面） 制定操作计划（人民币就像兵，不要当作赌博） 确定买卖时机 （主要依靠分析技术指标） 技术分析的基础知识 基本要素：量价时空 最大优点：贴近市场，获得收益周期短，见效快 主要方法：K线分析、切线分析、形态分析（w底m头）、技术指标（MACD） 适用范围：短期投资操作，长期投资预测一定要和基本面结合！ 技术分析是概率的，不可能百分百正确！ K线理论浅析K线起源K线起源于18世纪中叶日本德川幕府时代，从事粮食生意的商人用于记录米价涨跌的一种图表。K线图形似蜡烛，故也称蜡烛图。（Candle前面发K音） K线含义K线4个价位是一个四维向量，反应股价的高低和变化趋势。按时间周期不同可以分为：5分钟K线、30分钟K线、60分钟K线、日K线、周K线、月K线、年K线等。 按4个价位的关系，K线可以分成3类：阳线类、阴线类、非阳非阴类。 记录方法 收盘价&gt;开盘价 红色 开盘价&gt;收盘价 绿色 K线类型 阳线类 ​ a. 没有上下影线的阳线，表明开盘以后，买方势强，股价节节攀升，尾市收于当日最高价。如果涨幅很大，则称大阳线；涨幅小，则称小阳线。 b. 无上影线有下影线的阳K线，表明开盘后股价曾经在某一时刻跌破开盘价，创出全日最低。其后，由于买盘力量强大，股价向上突破开盘价，并以全天最高价收盘。 c. 无下影线有上影线的阳K线，开盘价即是全日最低价，然后股价上升到最高价，收盘时受挫回落构成上影线，但收盘价仍然在开盘价之上。此类K线表明股价在上升中遭受到阻力、但股价仍然在上升。 d. 有上下影线的阳线，实体与影线的关系，以开盘价和收盘价为平衡位。 阴线类 a. 没有上下影线的阴线，表明开市后，股价一路下跌，并以最低价收盘，开盘价即是最高价。 b. 无下影线有上影线的阴K线，属先涨后跌型，收盘价是全日最低价。也称光脚阳线，一般代表行情看淡。 c. 无上影线有下影线的阴K线（图有问题），表明股价先跌而后有所回升，构成下影线收盘。一般说明下档虽然出现了支撑，但行情一时还难以变好。 d. 有上下影线的阴线。 非阳非阴类 a. T字形K线，收盘价等于开盘价，也等于最高价。如果在高位，就是见顶信号。 b. 一字线，最高价、最低价、收盘价、开盘价均相等，全天只有一个成交价。上升期中表示强势，啪啪涨停板；下降期就是弱势（乐视网）。 c. 十字形K线，表明股价曾高于及低于开盘价，但收盘价与开盘价相同。高位见顶信号，低位见底信号。 d. 倒丁字形K线，收盘价等于开盘价，且等于最低价。开盘后涨幅较大，收盘时跌至最低，以开盘价收市。也称零位线。 注意：单独的图形是不能用来判断行情的，一定要结合趋势！！！ 移动平均线使用软件：通达信（随个人喜好） 什么是移动平均线移动平均线（MA，Moving Average）：是以道琼斯的“平均成本概念”为理论基础，采用统计学中“移动平均”原理，将一段时间内的股票价格平均值连成曲线，用来显示股价的历史波动情况，进而反映股价指数未来发展趋势的技术分析方法。 依照计算周期可以分为短期（5、10日），中期（30日）和长期（60、120日）。 MA5：5日平均线，白色。 MA10：10日平均线，黄色。 MA30：30日平均线，紫色。 MA60：60日平均线，绿色。 移动平均线运用法则移动平均线所表示的意义 事先声明：以下所有判断均有一定滞后性！！！ 上升行情初期，短期移动平均线从下向上突破中长期移动平均线，形成的交叉叫黄金交叉。预示股价将上涨。如图所示，5日均线上穿10日均线形成的交叉。10日突破30日也是黄金交叉。 当短期移动平均线向下跌破中长期移动平均线形成的交叉叫做死亡交叉。预示股价将下跌。如图所示，10日均线下穿30日均线。 在上升行情进入稳定期，5、10、30日移动平均线从上而下依次顺序排列，向右上方移动，成为多头排列。预示股价将大幅上涨。 在下跌行情中，5、10、30日移动平均线自下而上依次顺序排列，向右下方移动，成为空头排列，预示股价将大幅下跌。 在上升行情中，股价位于移动平均线之上，走多头排列的均线可视为多方的防线；当股价回档至移动平均线附近时，各条移动平均线依次产生支撑力量，买盘入场推动股价再度上升，这就是MA的助涨作用。 在下跌行情中，股价在移动平均线的下方，呈空头排列的均线可以视为空方的防线，当股价反弹到移动平均线附近时，便会遇到阻力，卖盘涌出，促使股价进一步下跌，这就是MA的助跌作用。 成交量怎么看有句老话：新手看价，高手看量，老手看势。 这里的量就是指成交量，也是分析庄家动向的重要依据。 成交量是K线图下方的副图。 柱状图颜色与K线一致，高度表示买卖的数量。 多头市场特征和空头市场特征多头就是看涨股票的人 多头市场特征： 股价上升，成交量增加 股价回档，成交量减少 股价盘整，成交量萎缩 股价再度上升，成交量随之增加 红色阶段股价上升，成交量上升； 紫色阶段股价盘整，成交量萎缩； 绿色阶段，股价回档，成交量减少。 空头是指看空后市，看跌的人 股价下跌，成交量减少 股价反弹，成交量增加 股价盘整，成交量减少 股价再度下跌，成交量下跌 可以看到人气越来越弱。 多空平衡——市场上看涨和看跌的人势力基本均衡 成交量小技巧温和放量一般出现在市场底部区域，并且在这之前已经出现了一波下跌或者行情调整。 巨量，是指股价在运行过程中突然放出巨大的成交量，一般当天放出的成交量至少是前一天的两倍以上。 天量见天价不一定正确！如图： 股价在下跌过程中出现巨量，一般标志着做空能量的最后一次释放，股价会出现反弹。 股价在上升期中出现巨量，一般意味着动能的耗尽，股价会出现回调或者滞涨。 地量，指成交量呈现极度缩小的状态，表明盘中交易相当的冷淡，成交很不积极。 这种情况一般出现在股价经过一波长期下跌的底部区域。 地量一般会出现阴跌不止的现象，或者证明主力把筹码锁的很死。 通过把股价锁定在底部，洗出不坚定的散户，为盈利做准备。 MACD指标MACD指标概念和原理趋向指标——平滑异同移动平均线（MACD，Moving Average Convergence Divergence），是Geral Appel于1979年提出的，它是一项利用短期（常用为12日）移动平均线和长期（常用为26日)移动平均线之间的聚合与分离状况，对买进、卖出时机做出研判的技术指标。有“指标之王”的美誉。 打开软件，最下面的副图就是MACD，双击可展开。 MACD图中也有金叉和死叉，这里的金叉是指白线从下往上上穿黄线，反之则是死叉。 MACD指标简单实战技巧 情况一：低位金叉 DIFF线（白）与DEA线（黄）金叉的位置，如果出现在零轴下方，并且远离零轴，这个金叉就称为低位金叉。投资者可将此时的金叉，仅仅视为股价的一次短期调整。 情况二：零轴附近金叉的买点 如果上涨趋势已经形成，DIFF线与DEA线的金叉发生在零轴附近，那么此时是投资者买入的绝佳时机。 情况三：高位金叉的买点 如果DIFF线与DEA线的金叉发生在零轴以上，且处于距离零轴较远的区域，那么该金叉就被称为高位金叉，高位金叉一般出现在股价上涨过程中的回调。高位金叉一般也是可以买入的。 情况一：低位死叉的卖点 低位死叉，是指发生在零轴下方较远地方的死叉。这种低位死叉，经常出现在下跌趋势中向上反弹结束时，因此低位死叉是反弹结束的卖出信号。此时，没有入场的投资者要注意持币观望，仍然持有股票被深度套牢的投资者，要注意风险。 情况二：零轴附近死叉的卖点 如果之前的市场方向一直都是下跌趋势，此时DIFF线在零轴附近跌破DEA线形成的交叉被称为零轴附近死叉，它表明市场在零轴附近已经积聚了较多的做空能量，死叉出现，预示着市场向下的动能开始释放，股价接下来将延续原来的下跌趋势。 分时走势图打开软件，选中一只股票，点开，默认是显示日线图，在上方菜单栏中选择分时按钮，即可调出分时图。 什么是走势图分时走势图也叫即时走势图，它是把股票市场的交易信息实时地用曲线在坐标图上加以显示的技术图形。坐标的横轴是开市的时间，纵轴的上半部分是股价或指数，下半部分显示的是成交量（黄色）。分时走势图是股市现场交易的即时资料。 分时走势图分为指数分时走势图和个股分时走势图。 分时走势图中的名词及含义上图就是上证指数的分时图，白色曲线表示上证交易所对外公布的大盘指数，也就是加权数。黄色曲线是不考虑上市股票发行数量的多少，将所有股票对上证指数的影响等同对待，是不含加权数的大盘指数。 参考白色曲线和黄色曲线的相对位置关系，可以得到以下信息： 当指数上涨，黄色曲线在白色曲线走势之上时，表示发行数量少（盘小）的股票涨幅较大；而当黄色曲线在白色曲线走势之下，则表示发行数量多（盘大）的股票涨幅较大。 当指数下跌时，如果黄色曲线仍然在白色曲线之上，这表示小盘股的跌幅小于大盘股的跌幅；如果白色曲线反居于黄色曲线之上，则说明小盘股的跌幅大于大盘股的跌幅。 红色、绿色的柱线反映当前大盘所有股票的买盘和卖盘的数量对比情况。红柱增长，表示买盘大于卖盘，指数将逐渐上涨；红柱缩短，表示卖盘大于买盘，指数将逐渐下跌。绿柱增长，指数下跌量增加；绿柱缩短，指数下跌量减小。黄色柱线表示每分钟的成交量，单位为手。 个股的分时走势图就不一样了。 白色曲线表示该种股票分时成交价格，黄色曲线表示该种股票的平均价格。下方柱线是每分钟的成交量。 分时图旁边有一些名词： 外盘指成交价是卖出价时，成交手数的总和；内盘指成交价是买入价时成交手数的总和。 当外盘&gt;&gt;内盘时，且股价也在上涨过程中，表明很多人在抢盘；当外盘&lt;&lt;内盘时，且股价在下跌，表明很多在抛售。（简单的方法就看颜色） 卖一 ~ 五是委托卖出的价格，买一 ~ 五委托买入的价格。旁边黄色的是是委托的手数。 委比：委买与委卖手数之差与之和的比例。 委差：委买手数与委卖手数的差值。 当委比是正值的时候，表示买方的力量强，上涨的概率大；反之，同理。（但这个指标容易作假） 量比：当日总成交手数与近期平均成交手数的比值。&gt;1表示这个时刻的成交手数放大了，&lt;1代表是萎缩的。 PE：市盈率。属于基本面。 股市切线法之趋势线这一节很玄学，大家看看就好。 股票市场价格随着时间的推移，在图表上会留下其运行轨迹，这一轨迹呈现一定的方向性，方向性反映了价格的波动情况。简单地说，趋势就是价格波动的方向，或者说是证券市场运动的方向。 上升趋势线上升趋势线是在股价持续上涨过程中，将每次的调整低点相连而成的趋势线。 下降趋势线股价在持续下跌过程中，将每次的反弹高点相连而形成的趋势线。 对趋势线突破翻转的应用技巧一般来说，趋势线对价格今后的变动起约束作用，使价格总保持在这条趋势线的上方（上升趋势线）或下方（下降趋势线）。实际上，就是起支撑和压力的作用。 趋势线被突破后，就说明价格下一步的走势将要向相反的方向运行，越重要越有效的趋势线被突破，其转势的信号越强烈。 筹码理论筹码是什么在股市中，筹码是投资者手中持有的一定数量的股票。 在软件右下方点击“筹”即可查看筹码分布。 股票的交易是买卖双方在某个价位，进行成交而实现。随着价格的上升或下降，会在不同的区域产生不同的成交量。在不同价位的分布量，就造成了不同价位的持仓成本。点击右下方的“笔”，这个流通盘是固定的，这里有9.56亿的流通盘，就有9.56亿的筹码。将不同价位的筹码按照不同价位横向排列起来，就形成了筹码分布，如上图。 分布图中有不同的颜色，具体的解释在图例中有标注。例如，红色的表示5周期前成本，对于日线来说，就是往前5日~1日；粉红色是10周期成本，就是往前10日~5日。 筹码分布图的作用 能有效判断行情的性质和趋势 如果K线处于筹码密集区的上方，表示行情较强，即时回调也是暂时的；如果K线在大量筹码下方，则意味着行情较弱，很多人被套牢了。 能有效识别主力建仓和出货的全过程 一般分为建仓、洗盘、拉升、出货几个阶段。下面几幅图再现了完整的过程，到最后，筹码分布在K线两侧，散户没有实力继续拉升，只能被套牢。 ​ 能有效的判断行情发展中重要的支撑位和阻力位 可以从上面的主力出货过程看到，当大部分筹码分布于K线以下时，一般可以持积极心态；而当大部分筹码分布于K线以上时，则要小心谨慎。 认识庄家庄家的分类一、按照运作周期来分：长线庄家、中线庄家、短线庄家 长线运作周期至少1年，上涨幅度至少一倍，控盘程度很高，能达到60%~80%，有明显坐庄痕迹，庄家实力雄厚，在宏观面、政策面、个股基本面都有一个很好的把握；中线周期一般在半年到一年，控制的筹码在50%左右，上涨幅度在40%以上，中线庄家往往借助中级行情，利用一些利好以及一些个股基本面的重大变化来拉高，或者通过板块联动；短线周期仅为几周或几个月，多见于强反弹的走势中，股价相对低的时候快速拉升，吸引中小散户。 二、按照庄家的主体性质来分： 政府庄家、券商庄家、上市公司庄家、基金庄家 政府庄家：在股市极度低迷的时候才会介入，主要为了维护国家金融秩序，防止经济崩溃。拥有雄厚的资金和配套的政策。 券商庄家：证券公司自己坐庄股票。信息融通，对金融政策反映灵敏，利用担当上市公司的推荐人，在第一时间了解上市公司的基本信息，市场上流通的被散户知晓的信息往往已经过时。注重成交量，可以多收手续费。必要的时候，明知亏本也会坐庄，主要是对成交的新股或者配股的股票进行护盘。 上市公司庄家: 自己炒自己的股票。对本公司的信息了如指掌。为了维护公司形象，会出手护盘，做亏本生意。 基金庄家：注重价值，注重绩优股。组合投资分散风险，力求保证资金的安全。与投资基金管理公司所属券商有千丝万缕的联系，在选股上有较强的契合性。 庄家的优势 资金的优势 高抛低吸，围点打援 消息方面的优势 信息渠道，包含获取的渠道和传播的渠道。尤其是上市公司的内幕信息。有时候会散播假消息，迷惑散户。 人才方面的优势 拥有一批高水平的操盘手、公关人才、行业分析师。 庄家与股评人之间的关系 股评人不知道自己被利用 庄家会关注一些著名股评人，适当配合股评人的预测。股评家最后落得个”股托“的名声。 股评人被庄家收买 送现金、送股票、送分红。吸货的时候，大唱悲观论调，动摇股民信心；吸住货时，又大肆吹捧，该股有成长性，有潜力。 庄家自己就是股评人 大机构会专门培养股评人。]]></content>
      <categories>
        <category>经济</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Draw multiple polylines on Google Map with Python]]></title>
    <url>%2F2018%2F10%2F12%2FDraw-multiple-polylines-on-Google-Map-with-Python%2F</url>
    <content type="text"><![CDATA[起因类似拥堵路段的绘制，我们需要在地图上根据风险程度，对不同的街道着以不同的颜色。 困难 关于绘制线段，Google Maps 只提供了 JavaScript API, 而我对JavaScript不熟。 数据文件在本地，需要进行预处理，JS并不擅长做数据处理和分析。 Google 提供的example只有相连的polyline(轨迹)， 而我需要的是绘制很多割裂的线段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Simple Polylines&lt;/title&gt; &lt;style&gt; /* Always set the map height explicitly to define the size of the div * element that contains the map. */ #map &#123; height: 100%; &#125; /* Optional: Makes the sample page fill the window. */ html, body &#123; height: 100%; margin: 0; padding: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="map"&gt;&lt;/div&gt; &lt;script&gt; // This example creates a 2-pixel-wide red polyline showing the path of // the first trans-Pacific flight between Oakland, CA, and Brisbane, // Australia which was made by Charles Kingsford Smith. function initMap() &#123; var map = new google.maps.Map(document.getElementById('map'), &#123; zoom: 3, center: &#123;lat: 0, lng: -180&#125;, mapTypeId: 'terrain' &#125;); var flightPlanCoordinates = [ &#123;lat: 37.772, lng: -122.214&#125;, &#123;lat: 21.291, lng: -157.821&#125;, &#123;lat: -18.142, lng: 178.431&#125;, &#123;lat: -27.467, lng: 153.027&#125; ]; var flightPath = new google.maps.Polyline(&#123; path: flightPlanCoordinates, geodesic: true, strokeColor: '#FF0000', strokeOpacity: 1.0, strokeWeight: 2 &#125;); flightPath.setMap(map); &#125; &lt;/script&gt; &lt;script async defer src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;callback=initMap"&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解决方案最终我选择用Python进行数据处理，将得到的处理结果以字符串形式插入到HTML文本中，保存，即可在浏览器中查看结果。 注意： string.format() 插入参数处需用“{}”标识，原有的“{}”需用“&#123;&#123;&#125;&#125;”代替。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def genHTML(filepath): polylines, pathcolors = getDataFromFile(filepath) return """ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Simple Polylines&lt;/title&gt; &lt;style&gt; /* Always set the map height explicitly to define the size of the div * element that contains the map. */ #map &#123;&#123; height: 100%; &#125;&#125; /* Optional: Makes the sample page fill the window. */ html, body &#123;&#123; height: 100%; margin: 0; padding: 0; &#125;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="map"&gt;&lt;/div&gt; &lt;script&gt; // This example creates a 2-pixel-wide red polyline showing the path of // the first trans-Pacific flight between Oakland, CA, and Brisbane, // Australia which was made by Charles Kingsford Smith. function initMap() &#123;&#123; var map = new google.maps.Map(document.getElementById('map'), &#123;&#123; zoom: 11, center: &#123;&#123;lat: 40.65, lng: -74.00&#125;&#125;, mapTypeId: 'roadmap' &#125;&#125;); var testpaths = [&#123;pathdata&#125;]; var testpathcolors = [&#123;pathcolors&#125;]; for (var i=0; i &lt;testpaths.length; i++)&#123;&#123; var polyline = new google.maps.Polyline(&#123;&#123; path: testpaths[i], geodesic: true, strokeColor: testpathcolors[i], strokeWeight: 2, strokeOpacity: 1 &#125;&#125;); polyline.setMap(map); &#125;&#125; &#125;&#125; &lt;/script&gt; &lt;script async defer src="https://maps.googleapis.com/maps/api/js?key=&#123;YOUR_API_KEY&#125;&amp;callback=initMap"&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; """.format(pathdata=polylines, pathcolors=pathcolors, YOUR_API_KEY="YourKey") ​ 生成后的HTML文件中的关键片段, 其中分离的线段可以通过多次调用setMap()实现： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt;function initMap() &#123; var map = new google.maps.Map(document.getElementById('map'), &#123; zoom: 11, center: &#123;lat: 40.65, lng: -74.00&#125;, mapTypeId: 'roadmap' &#125;); var testpaths = [ [&#123;lat: 40.64204491, lng: -73.98123241&#125;, &#123;lat: 40.64170758, lng: -73.98204322&#125;], [&#123;lat: 40.81448703, lng: -73.95545832&#125;, &#123;lat: 40.81365059, lng: -73.95349239&#125;], // More coordinates here... ] var testpathcolors = ['#EE00EE','#6495ED' //more color here... ] for (var i=0; i &lt;testpaths.length; i++)&#123; var polyline = new google.maps.Polyline(&#123; path: testpaths[i], geodesic: true, strokeColor: testpathcolors[i], strokeWeight: 2, strokeOpacity: 1 &#125;); polyline.setMap(map); &#125; &#125; &lt;/script&gt; 最终的结果：]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS前景思考]]></title>
    <url>%2F2018%2F08%2F12%2FCS%E5%89%8D%E6%99%AF%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[几年前选专业的时候，CS处于一个不温不火的状态，其实我本来最想去的是电气，不过最后阴差阳错地进了计算机相关的专业。社会上对程序员一直存在着一种偏见：木讷、不善交际、缺乏生活情趣、社会地位低、人脉资源少。身处这个行业的我虽然很不爽这种言论，但是就我亲身感受而言，这种偏见确实有其生长的土壤。我周围有很多优秀的技术大神，秉持着“技术至上”的理念，对技术的雕琢无可挑剔，但是不少人缺乏与人沟通的技巧，缺乏展示自我的手段和意愿，一心沉醉在技术世界，不闻窗外之事。加上近几年CS大热——留学申请难度逐年递增、海外CS从业人员回国抢食、转行潮、某些网络社区对CS的热捧，使得科班出身的从业人员内心骄纵之气日甚。 月满则亏，水满则溢。做人如此，行业也是如此。股市里有个非常著名的风向标：当菜市场大妈都知道要投资股市的时候，就是退场的最好时机。行业兴衰基本也符合这种规律，当大家一窝蜂地涌向某个行业时，这个行业离衰落也就不远了，至少相对于其本身不复辉煌，这是由市场的滞后性决定的。 这些年IT行业的发展也更加证实了这种判断。各种框架层出不穷，编程门槛和学习成本不断降低，开发效率越来越高，也正因为如此，产生了很多被科班人员嘲讽为“调包侠”的人，这应该是行业的进步，是生产力的进步，但对科班从业人员来说是其实是一种威胁，使得他们经年累月的知识积累无用武之地（有些夸张，但效用降低是真的），使得整体的待遇水平愈发趋近于社会平均水平。 也许有人会说，我不会变成调包侠，我要专注于计算机技术，把技术打磨到极致？很遗憾，这条路过于艰难。打磨到极致当然有用，但是有几人能够打磨到极致呢？技术的提升同样遵循经济学规律，越到后面，你需要投入时间、精力就越多，边际效益递减，边际成本剧增，况且高级技术职位的坑也就那么几个，你有多少信心认定那个坑一定是你的？另一方面，即使你跟上了技术发展的潮流也是不够的。以深度学习为例，这些岗位对知识的要求够高了吧？从2012大放异彩，到如今5年过去，从手撕神经网络，到caffe, tensorflow, 再到如今的keras, 深度学习也渐渐变成只要搭搭积木就能解决问题的技术。这样一来，懂得其他行业专业知识的人虽然代码写得不如科班人员迅速高效，但他们能解决计算机人员无法解决的问题（科班往往只关注计算机本身），由此创造的效益会超过科班高效节省的成本，整个社会会选择哪一种人不言自明。 和唯物史观认为的不同，计算机的历史更像是天才引领的历程，大多数普通人仅仅只是使用者，未来的计算机注定成为一种通用性的工具，CS专业也会变成一个普通的专业。作为科班人员，要正视这种危机，我们真正应该关注的是，如何利用计算机解决各行各业的问题，如何利用自己对计算机的深刻理解建立独一无二的个人价值。]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记忆体系与学习方法]]></title>
    <url>%2F2018%2F08%2F12%2F%E8%AE%B0%E5%BF%86%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高中及其之前的学习，老师都要求我们尽可能地掌握每一个知识点，这种学习方法的唯一目的就是为了在考试中取得高分。但是进入大学以后，知识量爆炸性地增长使得这种方法的学习效率变得很低，同时大学的学习不再纯粹地以分数为导向，更多地以解决实际问题为目标（为了找工作也算一种吧），在这种需求的推动下，势必要对原有的学习方法做出改进。 人脑的的历史可以追溯至万年以前，在这万年间，脑硬件的升级几乎微乎其微，而科技几百年的积累已经让它不堪重负，前沿研究员培养周期的延长便是最好的证明。这个问题很大程度上由人脑的存储结构造成的。人在思考的时候，能存储的条目至多不会超过七个，换句话说，人脑其实顶多只有七个寄存器而已；同时，已经存储在人脑中的知识如果不经常用，也会渐渐遗忘，就好比内存，掉电或者频繁地切换内容也会导致原有记忆的丢失；由此，人们发明了各种工具来辅助记忆，从石板、竹简、印刷、电子存储，再到互联网，人类获取外部知识的成本越来越低。 其实我们完全可以借鉴计算机存储体系设计的思路来优化我们的学习方法。因为我们最终的目标是解决问题，完成项目，所以重要的并不是你记住了哪些可以解决问题的手段（当然在具体的学习中过一遍脑子还是需要的），而是应该知道去哪里能找到解决问题的方法 。思维导图一类工具的出现大大简化了对知识建立索引的过程，索引的体量要远远小于对应的知识总量，减轻了大脑的记忆负担。剩下的工作就是要确定问题属于哪一类？该用哪一种手段解决？确定后到对应的索引中去找即可。那如果现有的记忆索引中没有呢？找资料-&gt;学习理解-&gt; 建立索引-&gt;添加至索引数据库，OK, Done。 上面的过程其实就是很多介绍学习方法的大牛所说的建立知识体系 ，结构化、体系化的知识确实更适应大脑的特点。]]></content>
      <categories>
        <category>生而为人</category>
      </categories>
      <tags>
        <tag>Muse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习与电路理论]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[在Coursera上学习吴恩达的DeepLearning.ai时遇到了一个疑惑——为什么一定要深度学习？ 为什么要添加多个隐藏层？吴恩达给出了两种解释：1. 类比人脑， 越靠近输入的层学习越简单的特征，越靠近输出的层将前面各层的特征组合起来学习更加复杂的特征。2. 电路理论。 电路理论 There are functions you can compute with a “small” L-layer deep nerual network that shallower networks require exponentiall more hidden units to compute. 例如异或操作： 其中第一种解释很直观，第二种解释虽然直觉上是认可的，但应该有更通俗明白的解释。 假设输入三位数据$x_1x_2x_3$（e.g. 001), 采用深层网络可以拟合为$x_1⊕x_2⊕x_3$，而浅层网络拟合成什么样呢？这个时候就需要借助数电中根据真值表写逻辑表达式的技巧。 真值表如下 $x_1$ $x_2$ $x_3$ True Value 0 0 0 0 0 0 1 1 0 1 0 1 1 0 0 1 1 1 0 0 1 0 1 0 0 1 1 0 1 1 1 1 所以浅层网络推导为： $x_1⋅x_2⋅x_3+x_1′⋅x_2′⋅x_3+x_1′⋅x_2⋅x_3′+x_1⋅x_2′⋅x_3′$ 显然，深层网络需要的电子器件数为$O(logn)$, 而浅层网络需要$2^{n-1}$指数数量的器件，深层网络的拟合能力要远远强于浅层网络。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纽约犯罪风险预测结果可视化]]></title>
    <url>%2F2018%2F06%2F05%2F%E7%BA%BD%E7%BA%A6%E7%8A%AF%E7%BD%AA%E9%A3%8E%E9%99%A9%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[毕设炼丹已经很心累了，系里还强行要求论文也得弄个3~5min视频解说，手动尼克杨问号脸？？？反正现在视频怎么做还没思路，就先把纽约市的犯罪风险预测结果做个可视化吧。 技术路线数据科学领域……不用Python是不可能的，这辈子都不可能不用python的，Basemap嫌太丑，Echarts又不会，Plotly还要注册，就只能靠geoplotlib勉强混混日子这样子。 前期准备三个文件：2015年纽约犯罪风险等级预测结果risk4visualization.csv（毕设结果），纽约人口普查区域编号和实际社区编号的映射文件cd2puma.json（手动编写的）, 纽约社区边界文件Community_Districts.geojson（点此下载）。 绘制风险图设置颜色级别, 风险等级分为0~5级，共六个级别： 1cmap = ColorMap('Reds', alpha=255, levels=6) 获取颜色，这个函数在绘制每个区域时都会被调用，根据index来查找对应的风险等级，再转化为颜色。这里用的to_color()其实是用于连续值映射的，后来翻阅文档时发现了对应于离散值映射的函数create_set_cmap and colorbrewer，效果应该没差多少也就懒得改了。 123456789def get_color(properties): key = properties['boro_cd'] demogra_no = cd2puma.get(key) if demogra_no is None: return [0, 0, 0, 0] index = ((recorddate - datetime(2015, 1, 1)).days * 24 + hour) * 55 + pumalist.index(demogra_no) return cmap.to_color(riskLevel.ix[index, '0.0'], 5, 'lin') 绘制函数，考虑到区域内部用了红色，边界用暖色调会和谐一点，这里选用镉黄色，rgb(255, 153, 18)（颜色表参考）： 1234567def draw_riskmap(filename): geoplotlib.set_window_size(800, 600) geoplotlib.geojson('data/Community_Districts.geojson', fill=True, color=get_color) geoplotlib.geojson('data/Community_Districts.geojson', color=[255, 153, 18, 100]) geoplotlib.set_smoothing(True) geoplotlib.set_bbox(BoundingBox) geoplotlib.savefig('imgs/'+ filename) geoplotlib库还不支持添加图例和文字说明，这里迂回了一下，派生了一个TextLayer类，重写了draw()方法，使用ui_manager在图右上角添加时间信息。 123456class TextLayer(BaseLayer): def draw(self, proj, mouse_x, mouse_y, ui_manager): datestr = recorddate.strftime('%Y-%m-%d ') hourstr = str(hour) + ":00" ui_manager.info(datestr + hourstr) main()中绘制从2015年12月1日0点至2015年12月2日23点，共48h的风险图。 1234567dates = [datetime(2015, 12, 1), datetime(2015, 12, 2)]for recorddate in dates: for hour in range(24): filename = str((recorddate - dates[0]).days * 24 + hour) geoplotlib.add_layer(TextLayer()) draw_riskmap(filename) 制作动图将上述获得的48张图片导入PS中，在时间轴中添加帧动画制作GIF。结果如下： geoplotlib使用体验在CartoDB Positron提供的背景地图支持下，geoplotlib绘制的图显得精致了不少（当然不能和Echarts这种大杀器相提并论），不过文档和示例还有所欠缺，很多API仅仅靠reference没办法搞清楚用法，只能通过查看源码实现自行领会，或者查看github issue来拾点牙慧。 参考资料User Guide https://github.com/andrea-cuttone/geoplotlib/wiki/User-Guide Andrea Cuttone，Sune Lehmann，Jakob Eg Larsen Geoplotlib: a Python Toolbox for Visualizing Geographical Data https://arxiv.org/abs/1608.01933]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kindle 订阅RSS]]></title>
    <url>%2F2018%2F06%2F04%2FKindle-%E8%AE%A2%E9%98%85RSS%2F</url>
    <content type="text"><![CDATA[前几天去配运动眼镜竟然查出了散光，说穿了还是自己作的，明知道睡前躺着水手机伤眼睛，却还是乐此不疲。以前也强迫过自己不把手机带上床，然而收效甚微。那就换个思路吧，既然改变不了睡前看文章的习惯，那就改变文章的载体。相对来说，kindle墨水屏对视力友好了许多。 TIPS: 推荐自备梯子 Reabble 是 Kindle 上的 RSS 新闻阅读器，专为使用电子墨水屏的浏览器设计交互界面，媲美系统原生阅读体验。它使用一款非常优秀的 RSS 阅读器 Inoreader.com 来提供订阅管理。 要使用 Reabble，你首先需要有一个 Inoreader 帐号(点此注册)，并在里面添加一些订阅，需要指出的是，国内访问Inoreader不太稳定。 Reabble支持两种阅读方式, 在线阅读和离线阅读。 1. 在线阅读打开 Kindle 主屏右上角的菜单，选择「体验版网页浏览器」并打开网址 reabble.com，使用 Inoreader 帐号密码登录。 2. 离线阅读登录 Reabble.com ，打开 Reabble 左下角菜单，选择「推送设置」， 设置完成后，你会在每天指定的时间自动收到文章（接收文件时 Kindle 必须连网）。 Reabble 需要你指定哪些订阅源是自动推送的。在 Inoreader 中选中要推送的单一订阅源， 然后点击工具栏上的「订阅源设置」，再点击「指定到新文件夹」，然后输入「Kindle」。 系统会自动推送所有添加到 Kindle 文件夹中的订阅文章。 参考资料：http://reabble.com/help]]></content>
      <categories>
        <category>电子设备</category>
      </categories>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 1803更新导致l2tp失效]]></title>
    <url>%2F2018%2F06%2F03%2FWin10-1803%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4l2tp%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[Win10的强制自动更新一直是个比较头疼的问题，前半个月为了跑代码就把更新时间设在了五月底，本以为交完论文后就可以高枕无忧了，结果头儿的要求比较高，以学校要求托底的愿望破灭，无奈之下只能继续加内容呗，but…坑爹的事情来了，服务器连不上了！！！准确的说，我的服务器需要通过VPN连接，但是VPN拨号一直失败。因为我所有的工作都在服务器端完成，本地基本没有原始数据和代码，这样就抓瞎了TT。 Google了一圈后，发现大多数方法讲的都是重启，重设VPN, 或者修改注册表，前两个试过了没卵用，第三个本着不熟悉的条目不乱改的原则没有尝试，但从底下评论来看，效果也是堪忧。 按照我对微软尿性的理解，这八成又是新更新惹的祸，所以利用win10自带的版本回退功能退回了1709，重新尝试连接之后，果然没有NG。 【填坑时间 2018.10.12】 方法：修改了注册表，向其中添加了一项。 123HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\PolicyAgent &quot;AssumeUDPEncapsulationContextOnSendRule&quot;=dword:0x00000002 参数的解释：https://support.microsoft.com/en-us/help/926179/how-to-configure-an-l2tp-ipsec-server-behind-a-nat-t-device-in-windows 这里还有一个疑问：我挂的VPN连的是校内网的服务器，应该不涉及NAT转换，但修改操作是有效的，不知何解？]]></content>
      <categories>
        <category>故障排除</category>
      </categories>
      <tags>
        <tag>系统故障</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, Hexo]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用Hexo + Github搭建个人网站, 是非常简单的一件事。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——我说的 感谢 Z皓的博客，我是跟着链接中的博文搭建现在的网站的，这篇博文中不会展示其中具体的每一步，仅仅对其中用到的重要的命令做一个总结，想看详细过程的同学可以直接移步链接中的博文。 其实从大三开始我就萌生了建立个站的想法，一方面是为了装逼，另一方面也是为了在这个世界上留下点什么，但是因为课业、比赛等种种原因一直搁置，这一拖就拖到了毕业……写完毕业论文后终于有一小段空闲时间，就把这个已经尘封的计划重新捡起来吧。 第一步：安装Node.js和Git, 在Github中建立个站的repo第二步：安装Hexo, 推荐新建一个blog文件夹1$ npm install hexo -g 检查Hexo是否安装成功 1$ hexo -v 初始化该文件夹(成功的话可以看到 “Start blogging with Hexo”) 1$ hexo init 安装所需的组件 1$ npm install 第三步：体验Hexo首次体验 1$ hexo g 开启服务器，访问本地服务器 1$ hexo s 如果端口被占用了 1$ hexo server -p &lt;port&gt; 第四步：将Hexo与Github page连接起来这里省略了设置Git的user name 和 email, 以及ssh key的配置过程。 配置Deployment, 找到网站根目录下的_config.yml文件， 修改repo信息 第五步：撰写博客新建一篇博文 1$ hexo new post &lt;blog-name&gt; 在生成以及部署文章之前，需要安装一个扩展 1$ npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以生成及部署了 1$ hexo d -g 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 到此，基本的搭建过程已经全部结束了，如果想更改博客的样式主题请参考进阶教程。 图片插入问题解决方法使用Markdown语法插入图片时，首页的显示是正常的，但是点击文章链接查看单篇时，所有的图片均无法正常显示。观察url可知，在首页时，url为：https://hostname/, 而转到单篇文章时url变成了：https://hostname/year/month/date/post-name, Markdown语法显然是失效的。 注意：以下方法仅针对hexo3及以上版本 找到_config.yml配置文件post_asset_folder项，设置为true。 此时创建新博文后在source/_post文件夹下会出现一个post-name.md文件和/post-name文件夹，将博文需要的图片都存放于此。 在文章中需要插入图片的地方输入： 1&#123;% asset_img &lt;filename&gt; 图片的说明 %&#125;]]></content>
      <categories>
        <category>网站建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>website</tag>
      </tags>
  </entry>
</search>
